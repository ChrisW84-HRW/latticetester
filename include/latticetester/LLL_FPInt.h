//
// This file is part of LatticeTester, although most of it is just a modified
// version of the `LLL_FP` module of NTL available at https://libntl.org/.
// It was modified because we wanted extra flexibility in the functions to improve
// the performance of our tools that use these functions.

#ifndef NTL_LLL_FPInt__H
#define NTL_LLL_FPInt__H

#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <vector>
#include <array>
#include <set>
#include <map>
#include <cmath>
#include <cstdlib>
#include <cstdint>
#include <type_traits>

#include <NTL/tools.h>
#include <NTL/fileio.h>
#include <NTL/vector.h>
#include <NTL/matrix.h>
#include <NTL/vec_double.h>
#include <NTL/ZZ.h>
#include <NTL/LLL.h>

#include <latticetester/Util.h>
// #include <latticetester/NTLWrap.h>

/**
 * This module contains a modified version of the `LLL_FP` module of NTL.
 * With the modified functions, the basis entries are in `Int`, which can be
 * either `int64_t` or `ZZ`.  We can also apply LLL or BKZ only to a submatrix
 * (first `r` rows and `c` columns) of the matrix `B` that is passed in and returned.
 * The returned basis will have `c` columns and at most `max(r,c)` rows
 * (the rank of the basis matrix), so it may not occupy the entire space in `B`.
 * With this flexibility, we can reserve a large block of
 * memory for the matrix `B` and reuse this same block (the same object `B`)
 * for thousands or millions of lattices that we want to analyze, even if the bases
 * have different dimensions.
 *
 * Another addition is the possibility to recover an array `sqlen` that gives the square
 * Euclidean lengths of the basis vectors, in `double`.
 * This array is maintained in the `LLL_FP` functions of NTL,
 * but it is hidden in the implementation and not accessible from outside.
 * In `IntLattice`, these lengths are maintained in a `RealVec` object,
 * which is not always an array of `double`, and the norm is not always the Euclidean one.
 * One has to be careful about that. This class does not use the Real type.
 *
 * Each function returns the dimension of the computed basis (number of independent rows).
 * This basis is always returned in the upper-left corner of the matrix `B`.
 * This differs from the `LLL_FP` functions, which returns the zero vectors at the top.
 */

typedef NTL::vector<Int> IntVec;
typedef NTL::matrix<Int> IntMat;
typedef NTL::vector<int64_t> vector64;

// Int modulus64(1048573);  // To test if basis entries ever exceed the modulus.

NTL_OPEN_NNS

/**
 * This function is similar to `LLL_FP` in NTL, but only the first `r` rows and
 * first `c` columns of the matrix `B` are considered, and a basis is built
 * for the lattice generated by these (partial) rows.  The other elements of
 * `B` are ignored. The basis is returned in the upper left corner of `B`,
 * with the shortest basis vector always in the first row.
 * If `r=0`, then all the rows of the `IntMat` object are taken.
 * If `c=0`, then all the columns are taken.
 * The square lengths of the returned basis vectors are also returned in the
 * `double` vector `sqlen`,  in `sqlen[0],..., sqlen[d-1]`, if this vector given.
 * The function returns the dimension of the computed basis (the number of independent rows).
 */
template<typename IntMat>
static long LLL_FPInt(IntMat &B, double delta = 0.99, long r = 0, long c = 0,
        Vec<double>& sqlen = 0);

/**
 * This function is similar to `BKZ_FP` in NTL, with the same modifications
 * as in LLL_FPInt above.
 */
template<typename IntMat>
static long BKZ_FPInt(IntMat &BB, double delta = 0.99, long blocksize = 10,
        long prune = 0, long r = 0, long c = 0, Vec<double>& sqlen = 0);

NTL_CLOSE_NNS

/* ============================================================== */

NTL_START_IMPL

static inline void CheckFinite(double *p) {
    if (!IsFinite(p))
        ResourceError("LLL_FP: numbers too big...use LLL_XD");
}

// Just to be safe!!
#define TR_BND (NTL_FDOUBLE_PRECISION/2.0)

// Returns the largest absolute value of the coordinates of v.
static double max_abs(double *v, long n) {
    double res, t;
    res = 0.0;
    for (long i = 0; i < n; i++) {
        t = fabs(v[i]);
        if (t > res)
            res = t;
    }
    return res;
}

// Returns the inner product of two arrays of double of size n.
static double InnerProductD(double *a, double *b, long n) {
    double s = 0.0;
    for (long i = 0; i < n; i++)
        s += a[i] * b[i];
    return s;
}

// Inner product of two vectors of integers a and b is returned in prod.
template<typename IntVec, typename Int>
static void InnerProductV(Int &prod, const IntVec &a, const IntVec &b, long n);

// The general case.
template<typename IntVec, typename Int>
void InnerProductV(Int &prod, const IntVec &a, const IntVec &b, long n) {
    LatticeTester::MyExit (1, "InnerProductV with types that do not match");
}

// The int64_t specialization.
template<>
void InnerProductV(int64_t &prod, const NTL::Vec<int64_t> &a, const NTL::Vec<int64_t> &b,
        long n) {
    long x = 0;
    for (long i = 0; i < n; i++) {
        x += a[i] * b[i];
    }
    prod = x;
}

// The ZZ specialization.
template<>
void InnerProductV(ZZ &prod, const NTL::Vec<ZZ> &a, const NTL::Vec<ZZ> &b,
        long n) {
    ZZ t1, x;
    clear(x);
    for (long i = 0; i < n; i++) {
        mul(t1, a[i], b[i]);
        add(x, x, t1);
    }
    prod = x;
}

/* // The mixed case.  Never used.
template<>
void InnerProductV(long &prod, const NTL::Vec<ZZ> &a, const NTL::Vec<ZZ> &b,
        long n) {
    ZZ t1, x;
    clear(x);
    for (long i = 0; i < n; i++) {
        mul(t1, a[i], b[i]);
        add(x, x, t1);
    }
    conv(prod, x);
}
*/

// A version for RR.
static void InnerProductR(RR &xx, const vec_RR &a, const vec_RR &b, long n) {
    RR t1, x;
    clear(x);
    for (long i = 0; i < n; i++) {
        mul(t1, a[i], b[i]);
        add(x, x, t1);
    }
    xx = x;
}

// ----------------------------------------------------------
// Returns 1 in `in_float` iff all the coefficients `a[i]` are within the bounds.
static void RowTransformStart(double *a, long *in_a, long &in_float, long n) {
    long inf = 1;
    for (long i = 0; i < n; i++) {
        in_a[i] = (a[i] < TR_BND && a[i] > -TR_BND);
        inf = inf & in_a[i];
    }
    in_float = inf;
}

template<typename IntVec>
static void RowTransformFinish(IntVec &A, double *a, long *in_a, long n) {
    for (long i = 0; i < n; i++) {
        if (in_a[i]) {
            conv(A[i], a[i]);
        } else {
            conv(a[i], A[i]);
            CheckFinite(&a[i]);
        }
    }
}

// ----------------------------------------------------------
// A = A - B*MU   for the first n vector entries only.
// The change is on the vector A.
template<typename IntVec, typename Int>
static void RowTransform(IntVec &A, IntVec &B, const Int &MU1, long n);

/*
// The int64_t case.  No longer used.
template<>
void RowTransform(NTL::Vec<long> &A, NTL::Vec<long> &B, const long &MU1, long n) {
    register int64_t MU = MU1;
    int64_t i;
    if (MU == 1) {
        for (i = 0; i < n; i++)
            A[i] -= B[i];
        return;
    }
    if (MU == -1) {
        for (i = 0; i < n; i++)
            A[i] += B[i];
        return;
    }
    if (MU == 0)
        return;
    for (i = 0; i < n; i++) {
        A[i] -= MU * B[i];
        if ((A[i] > modulus64) ||  (A[i] < -modulus64))
           std::cout << "RowTransform-64: A[i] = " << A[i] << "\n";
    }
}
*/

// The ZZ case.
template<>
void RowTransform(vec_ZZ &A, vec_ZZ &B, const ZZ &MU1, long n) {
    NTL_ZZRegister (T);
    NTL_ZZRegister (MU);
    long k, i;
    MU = MU1;
    if (MU == 1) {
        for (i = 0; i < n; i++)
            sub(A[i], A[i], B[i]);
        return;
    }
    if (MU == -1) {
        for (i = 0; i < n; i++)
            add(A[i], A[i], B[i]);
        return;
    }
    if (MU == 0)
        return;
    if (NumTwos(MU) >= NTL_ZZ_NBITS)
        k = MakeOdd(MU);
    else
        k = 0;
    if (MU.WideSinglePrecision()) {
        long mu1;
        conv(mu1, MU);
        if (k > 0) {
            for (i = 0; i < n; i++) {
                mul(T, B[i], mu1);
                LeftShift(T, T, k);
                sub(A[i], A[i], T);
            }
        } else {
            for (i = 0; i < n; i++) {
                MulSubFrom(A[i], B[i], mu1);
                //if ((A[i] > modulus64) ||  (A[i] < -modulus64))
                //   std::cout << "RowTransform-64: A[i] = " << A[i] << "\n";
            }
        }
    } else {
        for (i = 0; i < n; i++) {
            mul(T, B[i], MU);
            if (k > 0)
                LeftShift(T, T, k);
            sub(A[i], A[i], T);
            // if ((A[i] > modulus64) ||  (A[i] < -modulus64))
            //   std::cout << "RowTransform-64: A[i] = " << A[i] << "\n";
        }
    }
}

// ---------------------------------------------------------
// A = A - B*MU1  for the first n vector entries only.
// The change is on the vector A.
template<typename IntVec, typename Int>
static void RowTransform(IntVec &A, IntVec &B, const Int &MU1, long n,
        double *a, double *b, long *in_a, double &max_a, double max_b,
        long &in_float);

/*
// This int64_t version is no longer used.
template<>
void RowTransform(NTL::Vec<long> &A, NTL::Vec<long> &B, const int64_t &MU1, long n,
        double *a, double *b, long *in_a, double &max_a, double max_b,
        int64_t &in_float) {
    register int64_t T, MU;
    // int64_t k;
    double mu;
    conv(mu, MU1);
    CheckFinite(&mu);
    int64_t i;
    if (in_float) {
        double mu_abs = fabs(mu);
        if (mu_abs > 0 && max_b > 0 && (mu_abs >= TR_BND || max_b >= TR_BND)) {
            in_float = 0;
        } else {
            max_a += mu_abs * max_b;
            if (max_a >= TR_BND)
                in_float = 0;
        }
    }
    if (in_float) {
        if (mu == 1) {
            for (i = 0; i < n; i++)
                a[i] -= b[i];
            return;
        }
        if (mu == -1) {
            for (i = 0; i < n; i++)
                a[i] += b[i];
            return;
        }
        if (mu == 0)
            return;
        for (i = 0; i < n; i++)
            a[i] -= mu * b[i];
        return;
    }
    // std::cout << "RowTransform int64_t, not in_float! \n";
    MU = MU1;
    if (MU == 1) {
        for (i = 0; i < n; i++) {
            if (in_a[i] && a[i] < TR_BND && a[i] > -TR_BND && b[i] < TR_BND
                    && b[i] > -TR_BND) {
                a[i] -= b[i];
            } else {
                if (in_a[i]) {
                    conv(A[i], a[i]);
                    in_a[i] = 0;
                }
                sub(A[i], A[i], B[i]);
            }
        }
        return;
    }
    if (MU == -1) {
        for (i = 0; i < n; i++) {
            if (in_a[i] && a[i] < TR_BND && a[i] > -TR_BND && b[i] < TR_BND
                    && b[i] > -TR_BND) {
                a[i] += b[i];
            } else {
                if (in_a[i]) {
                    conv(A[i], a[i]);
                    in_a[i] = 0;
                }
                add(A[i], A[i], B[i]);
            }
        }
        return;
    }
    if (MU == 0)
        return;

    double b_bnd = fabs(TR_BND / mu) - 1;
    if (b_bnd < 0)
        b_bnd = 0;
    for (i = 0; i < n; i++) {
        if (in_a[i]) {
            conv(A[i], a[i]);
            in_a[i] = 0;
        }
        // A[i] = A[i] - B[i] * MU;
        mul(T, B[i], MU);
        sub(A[i], A[i], T);
        if ((A[i] > modulus64) ||  (A[i] < -modulus64))
            std::cout << "RowTransform-FP-64: i = " << i << ",  A[i] = " << A[i] << "\n";
    }
}
*/

template<>
void RowTransform(NTL::Vec<ZZ> &A, NTL::Vec<ZZ> &B, const NTL::ZZ &MU1, long n,
        double *a, double *b, long *in_a, double &max_a, double max_b,
        long &in_float) {
    NTL_ZZRegister (T);
    NTL_ZZRegister (MU);
    long k;
    double mu;
    conv(mu, MU1);
    CheckFinite(&mu);
    long i;
    // in_float == 1 (true) iff all coefficients are in [-TR_BND, TR_BND].
    if (in_float) {
        double mu_abs = fabs(mu);
        if (mu_abs > 0 && max_b > 0 && (mu_abs >= TR_BND || max_b >= TR_BND)) {
            in_float = 0;
        } else {
            max_a += mu_abs * max_b;
            if (max_a >= TR_BND)
                in_float = 0;
        }
    }
    if (in_float) {
        if (mu == 1) {
            for (i = 0; i < n; i++)
                a[i] -= b[i];
            return;
        }
        if (mu == -1) {
            for (i = 0; i < n; i++)
                a[i] += b[i];
            return;
        }
        if (mu == 0)
            return;
        for (i = 0; i < n; i++)
            a[i] -= mu * b[i];
        return;
    }
    MU = MU1;
    if (MU == 1) {
        for (i = 0; i < n; i++) {
            if (in_a[i] && a[i] < TR_BND && a[i] > -TR_BND && b[i] < TR_BND
                    && b[i] > -TR_BND) {
                a[i] -= b[i];
            } else {
                if (in_a[i]) {
                    conv(A[i], a[i]);
                    in_a[i] = 0;
                }
                sub(A[i], A[i], B[i]);
            }
        }
        return;
    }
    if (MU == -1) {
        for (i = 0; i < n; i++) {
            if (in_a[i] && a[i] < TR_BND && a[i] > -TR_BND && b[i] < TR_BND
                    && b[i] > -TR_BND) {
                a[i] += b[i];
            } else {
                if (in_a[i]) {
                    conv(A[i], a[i]);
                    in_a[i] = 0;
                }
                add(A[i], A[i], B[i]);
            }
        }
        return;
    }
    if (MU == 0)
        return;
    double b_bnd = fabs(TR_BND / mu) - 1;
    if (b_bnd < 0)
        b_bnd = 0;
    if (NumTwos(MU) >= NTL_ZZ_NBITS)
        k = MakeOdd(MU);
    else
        k = 0;
    if (MU.WideSinglePrecision()) {
        long mu1;
        conv(mu1, MU);
        if (k > 0) {
            for (i = 0; i < n; i++) {
                if (in_a[i]) {
                    conv(A[i], a[i]);
                    in_a[i] = 0;
                }
                mul(T, B[i], mu1);
                LeftShift(T, T, k);
                sub(A[i], A[i], T);
            }
        } else {
            for (i = 0; i < n; i++) {
                if (in_a[i] && a[i] < TR_BND && a[i] > -TR_BND && b[i] < b_bnd
                        && b[i] > -b_bnd) {
                    a[i] -= b[i] * mu;
                } else {
                    if (in_a[i]) {
                        conv(A[i], a[i]);
                        in_a[i] = 0;
                    }
                    MulSubFrom(A[i], B[i], mu1);
                    // if ((A[i] > modulus64) ||  (A[i] < -modulus64))
                    //   std::cout << "RowTransform: A[i] = " << A[i] << "\n";
                }
            }
        }
    } else {
        for (i = 0; i < n; i++) {
            if (in_a[i]) {
                conv(A[i], a[i]);
                in_a[i] = 0;
            }
            mul(T, B[i], MU);
            if (k > 0)
                LeftShift(T, T, k);
            sub(A[i], A[i], T);
            // if ((A[i] > modulus64) ||  (A[i] < -modulus64))
            //   std::cout << "RowTransform: A[i] = " << A[i] << "\n";
        }
    }
}

// -------------------------------------------------------
// A = A + B*MU  for the first n vector entries only.
// The change is on the vector A.  This is used once in BKZ.
template<typename IntVec, typename Int>
static void RowTransformAdd(IntVec &A, IntVec &B, const Int &MU1, long n) {
   LatticeTester::MyExit (1, "RowTransformAdd: the general case is not implemented.");
}

template<>
void RowTransformAdd(vector64 &A, vector64 &B, const int64_t &MU1, long n) {
    register int64_t T, MU = MU1;
    int64_t i;
    if (MU == 1) {
        for (i = 0; i < n; i++)
            add(A[i], A[i], B[i]);
        return;
    }
    if (MU == -1) {
        for (i = 0; i < n; i++)
            sub(A[i], A[i], B[i]);
        return;
    }
    if (MU == 0)
        return;
    for (i = 0; i < n; i++) {
        T = MU * B[i];
        A[i] += T;
    }
}

template<>
void RowTransformAdd(vec_ZZ &A, vec_ZZ &B, const ZZ &MU1, long n) {
    NTL_ZZRegister (T);
    NTL_ZZRegister (MU);
    long k, i;
    MU = MU1;
    if (MU == 1) {
        for (i = 0; i < n; i++)
            add(A[i], A[i], B[i]);

        return;
    }
    if (MU == -1) {
        for (i = 0; i < n; i++)
            sub(A[i], A[i], B[i]);
        return;
    }
    if (MU == 0)
        return;
    if (NumTwos(MU) >= NTL_ZZ_NBITS)
        k = MakeOdd(MU);
    else
        k = 0;
    if (MU.WideSinglePrecision()) {
        long mu1;
        conv(mu1, MU);
        for (i = 0; i < n; i++) {
            mul(T, B[i], mu1);
            if (k > 0)
                LeftShift(T, T, k);
            add(A[i], A[i], T);
        }
    } else {
        for (i = 0; i < n; i++) {
            mul(T, B[i], MU);
            if (k > 0)
                LeftShift(T, T, k);
            add(A[i], A[i], T);
        }
    }
}

// ----------------------------------------------------
// This one works with arrays of `double`.
template<typename IntMat>
static void ComputeGS(IntMat &B, double **B1, double **mu, double *b, double *c,
        long k, long n, double bound, long st, double *buf) {
    // k and st are both reduced by 1 compared with NTL version
    long i, j;
    double s, t1, y, t;
    Int T1;
    long test;
    double *mu_k = mu[k];

// std::cout << "ComputeGS, st = " << st << " k = " << k << "\n";
    if (st < k) {
        for (i = 0; i < st; i++)
            buf[i] = mu_k[i] * c[i];
    }
    for (j = st; j < k; j++) {
        s = InnerProductD(B1[k], B1[j], n);  // Returns a double.
        // std::cout << "ComputeGS, j = " << j << " Inner product s = " << s << "\n";

        // test = b[k]*b[j] >= NTL_FDOUBLE_PRECISION^2
        test = (b[k] / NTL_FDOUBLE_PRECISION >= NTL_FDOUBLE_PRECISION / b[j]);
        // test = test && s^2 <= b[k]*b[j]/bound,
        // but we compute it in a strange way to avoid overflow
        if (test && (y = fabs(s)) != 0) {
            t = y / b[j];
            t1 = b[k] / y;
            // std::cout << "ComputeGS, t1 = " << t1 << "\n";
            if (t <= 1)
                test = (t * bound <= t1);
            else if (t1 >= 1)
                test = (t <= t1 / bound);
            else
                test = 0;
        }
        if (test) {
            InnerProductV(T1, B[k], B[j], n);  // all in Int.
            conv(s, T1);
            // std::cout << "ComputeGS, T1 = s = " << s << "\n";
        }
        double *mu_j = mu[j];
        t1 = 0;
        for (i = 0; i < j; i++) {
            t1 += mu_j[i] * buf[i];
        }
        mu_k[j] = (buf[j] = (s - t1)) / c[j];
        // std::cout << "ComputeGS, mu_k[j] = " << mu_k[j] << "\n";
    }

#if (!NTL_EXT_DOUBLE)
// Kahan summation
    double c1;
    s = c1 = 0;
    for (j = 0; j < k; j++) {
        y = mu_k[j] * buf[j] - c1;
        t = s + y;
        c1 = t - s;
        c1 = c1 - y;
        s = t;
    }
#else
   s = 0;
   for (j = 0; j < k; j++)
      s += mu_k[j] * buf[j];
#endif
    c[k] = b[k] - s;
}

NTL_CHEAP_THREAD_LOCAL double LLLStatusInterval = 900.0;
NTL_CHEAP_THREAD_LOCAL char *LLLDumpFile = 0;

static NTL_CHEAP_THREAD_LOCAL double red_fudge = 0;
static NTL_CHEAP_THREAD_LOCAL long log_red = 0;

static NTL_CHEAP_THREAD_LOCAL unsigned long NumSwaps = 0;
static NTL_CHEAP_THREAD_LOCAL double RR_GS_time = 0;
static NTL_CHEAP_THREAD_LOCAL double StartTime = 0;
static NTL_CHEAP_THREAD_LOCAL double LastTime = 0;

template<typename IntMat>
static void LLLStatus(long max_k, double t, long m, long n, const IntMat &B) {
    cerr << "---- LLL_FP status ----\n";
    cerr << "elapsed time: ";
    PrintTime(cerr, t - StartTime);
    cerr << ", stage: " << max_k;
    cerr << ", rank: " << m;
    cerr << ", swaps: " << NumSwaps << "\n";

    Int t1;
    long i;
    double prodlen = 0;
    for (i = 0; i < m; i++) {
        InnerProductV(t1, B[i], B[i], n);   // all in Int.
        if (t1 != 0)
            // if (!IsZero(t1))
            prodlen += log(t1);
    }
    cerr << "log of prod of lengths: " << prodlen / (2.0 * log(2.0)) << "\n";
    if (LLLDumpFile) {
        cerr << "dumping to " << LLLDumpFile << "...";
        ofstream f;
        OpenWrite(f, LLLDumpFile);
        f << "[";
        for (i = 0; i < m; i++) {
            f << B[i] << "\n";
        }
        f << "]\n";
        f.close();
        cerr << "\n";
    }
    LastTime = t;
}

static void init_red_fudge() {
    long i;
    log_red = long(0.50 * NTL_DOUBLE_PRECISION);
    red_fudge = 1;
    for (i = log_red; i > 0; i--)
        red_fudge = red_fudge * 0.5;
}

static void inc_red_fudge() {
    red_fudge = red_fudge * 2;
    log_red--;
    cerr << "LLL_FP: warning--relaxing reduction (" << log_red << ")\n";
    if (log_red < 4)
        ResourceError("LLL_FP: too much loss of precision...stop!");
}

// #if ((TYPES_CODE  ==  ZD) || (TYPES_CODE  ==  ZR))

// The following functions always use RR matrices.  ***
// We do not use them when Int = int64_t.
// k and st are both reduced by 1 compared with NTL version

void ComputeGS(const mat_ZZ &B, mat_RR &B1, mat_RR &mu, vec_RR &b, vec_RR &c,
        long k, const RR &bound, long st, vec_RR &buf, const RR &bound2);

void ComputeGS(const mat_ZZ &B, mat_RR &B1, mat_RR &mu, vec_RR &b, vec_RR &c,
        long k, long n, const RR &bound, long st, vec_RR &buf,
        const RR &bound2) {
    std::cout << "We are now in this ComputeGS with RR vectors!!! \n";
    ComputeGS(B, B1, mu, b, c, k, bound, st, buf, bound2);
}

// The general case, only a declaration.
template<typename IntMat>
static void RR_GS(IntMat &B, double **B1, double **mu, double *b, double *c,
        double *buf, long prec, long rr_st, long k, long m_orig, long n,
        mat_RR &rr_B1, mat_RR &rr_mu, vec_RR &rr_b, vec_RR &rr_c);

// Specialization for `Int = int64_t`.
template<>
void RR_GS<NTL::matrix<long>>(NTL::matrix<long> &B, double **B1, double **mu,
        double *b, double *c, double *buf, long prec, long rr_st, long k,
        long m_orig, long n, mat_RR &rr_B1, mat_RR &rr_mu, vec_RR &rr_b,
        vec_RR &rr_c) {
    cerr << "This RS_GS for `long` does nothing. \n";
}

template<>
void RR_GS(NTL::matrix<ZZ> &B, double **B1, double **mu, double *b, double *c,
        double *buf, long prec, long rr_st, long k, long m_orig, long n,
        mat_RR &rr_B1, mat_RR &rr_mu, vec_RR &rr_b, vec_RR &rr_c) {
    // k and rr_st are both reduced by 1 compared with NTL version
    double tt;
    cerr << "LLL_FP: RR refresh " << rr_st << "..." << k << "...";
    tt = GetTime();
    if (rr_st > k)
        ResourceError("LLL_FP: rr_st > k, cannot continue!!!");
    RRPush push;
    RR::SetPrecision(prec);

    // long n = B.NumCols();
    // Here we reserve space for large RR matrices !!!
    rr_B1.SetDims(k, n);
    rr_mu.SetDims(k, m_orig);
    rr_b.SetLength(k);
    rr_c.SetLength(k);

    vec_RR rr_buf;
    rr_buf.SetLength(k);
    long i, j;
    for (i = rr_st - 1; i < k; i++)
        for (j = 0; j < n; j++)
            conv(rr_B1[i][j], B[i][j]);
    for (i = rr_st - 1; i < k; i++)
        InnerProductR(rr_b[i], rr_B1[i], rr_B1[i], n);   // all in RR.
    RR bound;
    power2(bound, 2 * long(0.15 * RR::precision()));
    RR bound2;
    power2(bound2, 2 * RR::precision());

    for (i = rr_st; i <= k; i++)
        ComputeGS(B, rr_B1, rr_mu, rr_b, rr_c, i, n, bound, 0, rr_buf, bound2);
    for (i = rr_st; i <= k; i++)
        for (j = 1; j <= n; j++) {
            conv(B1[i][j], rr_B1[i - 1][j - 1]);
            CheckFinite(&B1[i][j]);
        }
    for (i = rr_st; i <= k; i++)
        for (j = 1; j <= i - 1; j++) {
            conv(mu[i][j], rr_mu[i - 1][j - 1]);
        }
    for (i = rr_st; i <= k; i++) {
        conv(b[i], rr_b[i - 1]);
        CheckFinite(&b[i]);
    }
    for (i = rr_st; i <= k; i++) {
        conv(c[i], rr_c[i - 1]);
        CheckFinite(&c[i]);
    }
    for (i = 1; i <= k - 1; i++) {
        conv(buf[i], rr_buf[i]);
    }
    tt = GetTime() - tt;
    RR_GS_time += tt;
    cerr << tt << " (" << RR_GS_time << ")\n";
}

void ComputeGS(const mat_ZZ &B, mat_RR &mu, vec_RR &c, long k, long n) {
    mat_RR B1;
    vec_RR b;
    // We reserve space for temporary RR matrices !!!
    B1.SetDims(k, n);
    mu.SetDims(k, k);
    b.SetLength(k);
    c.SetLength(k);

    vec_RR buf;
    buf.SetLength(k);
    long i, j;
    for (i = 0; i < k; i++)
        for (j = 0; j < n; j++)
            conv(B1[i][j], B[i][j]);
    for (i = 0; i < k; i++)
        InnerProductR(b[i], B1[i], B1[i], n);
    RR bound;
    power2(bound, 2 * long(0.15 * RR::precision()));

    RR bound2;
    power2(bound2, 2 * RR::precision());
    for (i = 0; i < k; i++)   // Uses RR matrices.
        ComputeGS(B, B1, mu, b, c, i, n, bound, 0, buf, bound2);
}

// #endif

// The main LLL procedure.
// m is the number of rows (generating vectors), same value as in NTL
template<typename IntMat>
static long ll_LLL_FP(IntMat &B, double delta, double **B1, double **mu,
        double *b, double *c, long m, long n, long init_k);

// The int64_t version.
template<>
int64_t ll_LLL_FP(matrix<int64_t> &B, double delta, double **B1, double **mu,
        double *b, double *c, int64_t m, int64_t n, int64_t init_k) {
    // init_k and k are one less compared with NTL.
    int64_t i, j, k, Fc1;
    int64_t MU;
    double mu1;
    double t1;
    double *tp;
    // we tolerate a 15% loss of precision in computing
    // inner products in ComputeGS.
    static double bound = 1;
    for (i = 2 * int64_t(0.15 * NTL_DOUBLE_PRECISION); i > 0; i--)
        bound = bound * 2;
    double half_plus_fudge = 0.5 + red_fudge;
    k = init_k;

    vector64 st_mem;
    st_mem.SetLength(m + 2);
    int64_t *st = st_mem.elts();    // An array of integers.

    for (i = 0; i < k; i++)
        st[i] = i;
    for (i = k; i <= m; i++)
        st[i] = 0;    // With k=0, we do only this.

    UniqueArray<double> buf_store;
    buf_store.SetLength(m);
    double *buf = buf_store.get();

    vector64 in_vec_mem;
    in_vec_mem.SetLength(n);
    int64_t *in_vec = in_vec_mem.elts();

    UniqueArray<double> max_b_store;
    max_b_store.SetLength(m);
    double *max_b = max_b_store.get();
    // cerr << "LLL: after creating UniqueArray's \n";

    for (i = 0; i < m; i++)
        max_b[i] = max_abs(B1[i], n);

    int64_t in_float = 1;
    int64_t rst;
    int64_t counter;
    int64_t start_over;
    int64_t trigger_index;
    int64_t small_trigger;
    int64_t cnt;
    // int64_t m_orig = m;
    int64_t rr_st = 0;   // One less than in NTL.
    int64_t max_k = 0;
    int64_t swap_cnt = 0;

    while (k < m) {
        // std::cout << "ll_LLL FPInt enter while k < m with k = " << k << "\n";
        if (k > max_k) {
            max_k = k;
            swap_cnt = 0;
        }
        if (k < rr_st)
            rr_st = k;  // Both are 1 less than in NTL.
        if (st[k] == k)
            rst = 0;   // 1 less than in NTL.
        else
            rst = k;
        if (st[k] < st[k + 1])
            st[k + 1] = st[k];

        // std::cout << "LLL64: before ComputeGS, B1[k][1] = " << B1[k][1] << "\n";
        ComputeGS(B, B1, mu, b, c, k, n, bound, st[k], buf);
        CheckFinite(&c[k]);
        st[k] = k;
        // std::cout << "After ComputeGS, mu[k] = " << mu[k][0] << "  " << mu[k][1] << "  " << mu[k][2] << "  " << mu[k][3] << "\n";

        if (swap_cnt > 200000) {
            cerr << "LLL_FPInt: swap loop?\n";
            // In NTL, there is more stuff here...
        }
        counter = 0;
        trigger_index = k;
        small_trigger = 0;
        cnt = 0;
        int64_t thresh = 10;
        int64_t sz = 0, new_sz;
        do { // size reduction
            // std::cout << "do loop: k = " <<  k << ",  counter = " << counter << "\n";
            counter++;
            if ((counter & 127) == 0) {   // Should be 127
                new_sz = 0;
                for (j = 0; j < n; j++)
                    new_sz += NumBits(B[k][j]);
                if ((counter >> 7) == 1 || new_sz < sz) {  // Should be 7
                    sz = new_sz;
                } else {
                    cerr << "LLL_FPInt sz = " << sz << " not smaller; infinite loop? \n";
                    cerr << "new_sz = " << new_sz << ",  counter = " << counter << ",  k = " << k << "\n";
                    //  abort();
                }
            }
            Fc1 = 0;
            start_over = 0;

            // std::cout << "rst = " << rst << "\n";
            for (j = rst - 1; j >= 0; j--) { // both j and rst are 1 less than in NTL.
                t1 = fabs(mu[k][j]);
                // std::cout << "entered for loop: j =  " <<  j << "  \n";
                // std::cout << "mu[k,j] =  " <<  mu[k][j] << "  t1 =  " <<  t1 << "  \n";
                if (t1 > half_plus_fudge) {
                    // std::cout << "we have t1 > half_plus_fudge, j =  " <<  j << ",  Fc1 = " << Fc1 << "\n";
                    if (!Fc1) {
                        if (j > trigger_index
                                || (j == trigger_index && small_trigger)) {
                            cnt++;
                            if (cnt > thresh) {
                                std::cout << "inc_red_fudge():  cnt= " << cnt << ",  dim= " << n << ", B[1] = " << B[1] << " \n";
                                if (log_red <= 15) {
                                    while (log_red > 10)
                                        inc_red_fudge();
                                    half_plus_fudge = 0.5 + red_fudge;
                                } else {
                                    inc_red_fudge();
                                    half_plus_fudge = 0.5 + red_fudge;
                                    cnt = 0;
                                }
                            }
                        }
                        trigger_index = j;
                        small_trigger = (t1 < 4);
                        Fc1 = 1;
                        if (k < rr_st)
                            rr_st = k;
                        // std::cout << "ll_LLL FPInt calling RowTransformStart, k = " << k << ",  rr_st = " << rr_st << "\n";
                        RowTransformStart(B1[k], in_vec, in_float, n);
                    }
                    mu1 = mu[k][j];
                    // std::cout << "Before row transform, mu1 = " << mu1 << " \n";
                    if (mu1 >= 0)
                        mu1 = ceil(mu1 - 0.5);
                    else
                        mu1 = floor(mu1 + 0.5);

                    double *mu_k = mu[k];
                    double *mu_j = mu[j];

                    if (mu1 == 1) {
                        for (i = 0; i < j - 1; i++)
                            mu_k[i] -= mu_j[i];
                    } else if (mu1 == -1) {
                        for (i = 0; i < j - 1; i++)
                            mu_k[i] += mu_j[i];
                    } else {
                        for (i = 0; i < j - 1; i++)
                            mu_k[i] -= mu1 * mu_j[i];
                    }
                    mu_k[j] -= mu1;
                    conv(MU, mu1);
                    // std::cout << "Before row transform, mu1 = " << mu1 << " \n";

                    register int64_t T, MU2 = MU;
                    for (i = 0; i < n; i++) {
                        T = MU2 * B1[j][i];
                        B1[k][i] -= T;
                    }
                    // std::cout << "Before row transform, mu1 = " << mu1 << " \n";
                    // We have `in_float=1` if all entries of B1[k] are in [-TR_BND, TR_BND].
                    // The change must be on vector B[k].
                    // RowTransform(B[k], B[j], MU, n);
                    //  RowTransform(B[k], B[j], MU, n, B1[k], B1[j], in_vec,
                    //         max_b[k], max_b[j], in_float);
                    // std::cout << "After row transform, MU = " << MU << " \n";
                    // std::cout << "Basis after row transform: \n" << B << "\n";
                }
            }
        //std::cout << "ll_LLL FPInt before if Fc1 \n";
        if (Fc1) {
            // std::cout << "ll_LLL FPInt inside `if(Fc1)` \n";
                vector64 temp = B[k];
                RowTransformFinish(temp, B1[k], in_vec, n);
                B[k] = temp;
                max_b[k] = max_abs(B1[k], n);
                b[k] = InnerProductD(B1[k], B1[k], n);
                CheckFinite(&b[k]);
                ComputeGS(B, B1, mu, b, c, k, n, bound, 0, buf);
                CheckFinite(&c[k]);
                rst = k;
                // std::cout << "After ComputeGS in (Fc1), rst = " << rst << ",  max_b[k]= "
                //     << max_b[k] << ", did_rr_gs=  " << ", b[k]=  " << b[k] << "\n";
                // std::cout << "After ComputeGS in (Fc1), mu[k] = " << mu[k][0] << "  " << mu[k][1] << "  " << mu[k][2] << "  " << mu[k][3] << "\n";
            }
            // std::cout << "End of loop, B = " <<  B << "  \n";
        } while (Fc1 || start_over);  // End of `do` loop.
        // std::cout << "ll_LLL FPInt after while Fc1, k = " << k << "  b[k] = " << b[k] << "\n";
        // std::cout << "Basis after while Fc1 \n" << B << "\n";

        if (b[k] == 0) {
            for (i = k; i < m - 1; i++) {
                // swap(B[i], B[i+1]);
                B[i].swap(B[i + 1]);
                tp = B1[i];
                B1[i] = B1[i + 1];
                B1[i + 1] = tp;
                t1 = b[i];
                b[i] = b[i + 1];
                b[i + 1] = t1;
                t1 = max_b[i];
                max_b[i] = max_b[i + 1];
                max_b[i + 1] = t1;
            }
            for (i = k; i <= m; i++)
                st[i] = 0;
            if (k < rr_st)
                rr_st = k;
            m--;
            continue;
        }
// test LLL reduction condition
// std::cout << "Test reduction condition  \n";
        if (k > 0
                && delta * c[k - 1]
                        > c[k] + mu[k][k - 1] * mu[k][k - 1] * c[k - 1]) {
            // swap rows k, k-1
            swap(B[k], B[k - 1]);
            tp = B1[k];
            B1[k] = B1[k - 1];
            B1[k - 1] = tp;
            tp = mu[k];
            mu[k] = mu[k - 1];
            mu[k - 1] = tp;
            t1 = b[k];
            b[k] = b[k - 1];
            b[k - 1] = t1;
            t1 = max_b[k];
            max_b[k] = max_b[k - 1];
            max_b[k - 1] = t1;
            k--;
            NumSwaps++;
            swap_cnt++;
        } else {
            k++;
        }
    }
    return m;
}

// The ZZ version.
template<>
long ll_LLL_FP(matrix<ZZ> &B, double delta, double **B1, double **mu, double *b,
        double *c, long m, long n, long init_k) {
    long i, j, k, Fc1;
    ZZ MU;
    double mu1;
    double t1;
    double *tp;
    static double bound = 1.0;
    // we tolerate a 15% loss of precision in computing
    // inner products in ComputeGS.
    for (i = 2 * long(0.15 * NTL_DOUBLE_PRECISION); i > 0; i--)
        bound = bound * 2;
    double half_plus_fudge = 0.5 + red_fudge;
    // quit = 0;  // This seems to be always 0, never changed!
    k = init_k;
    vector64 st_mem;
    st_mem.SetLength(m + 2);
    long *st = st_mem.elts(); // An array of integers.

    for (i = 0; i < k; i++)
        st[i] = i;
    for (i = k; i <= m; i++)
        st[i] = 0;

    UniqueArray<double> buf_store;
    buf_store.SetLength(m);
    double *buf = buf_store.get();

    vector64 in_vec_mem;
    in_vec_mem.SetLength(n);
    long *in_vec = in_vec_mem.elts();

    UniqueArray<double> max_b_store;
    max_b_store.SetLength(m);
    double *max_b = max_b_store.get();

    // std::cout << "ll_LLL FPInt after Unique Arrays  \n";
    for (i = 0; i < m; i++)
        max_b[i] = max_abs(B1[i], n);
    long in_float = 1;
    long rst;
    long counter;
    long start_over;
    long trigger_index;
    long small_trigger;
    long cnt;

    // These RR matrices are declared here but not created yet.
    mat_RR rr_B1;
    mat_RR rr_mu;
    vec_RR rr_c;
    vec_RR rr_b;

    long m_orig = m;
    long rr_st = 0;   // One less than in NTL.
    long max_k = 0;
    long swap_cnt = 0;
    long prec = RR::precision();

    while (k < m) {
        // std::cout << "ll_LLL FPInt enter while k < m with k = " << k << "\n";
        if (k > max_k) {
            max_k = k;
            swap_cnt = 0;
        }
        if (k < rr_st)
            rr_st = k;    // Both are 1 less than in NTL.
        if (st[k] == k)
            rst = 0;     // 1 less than in NTL.
        else
            rst = k;
        if (st[k] < st[k + 1])
            st[k + 1] = st[k];

// std::cout << "ll_LLL FPInt before computeGS \n";
// This one uses only matrices of `double`.
        ComputeGS(B, B1, mu, b, c, k, n, bound, st[k], buf);
        CheckFinite(&c[k]);
        st[k] = k;
        // std::cout << "After ComputeGS, mu[k] = " << mu[k][0] << "  " << mu[k][1] << "  " << mu[k][2] << "  " << mu[k][3] << "\n";
//std::cout << "ll_LLL FPInt after computeGS \n";

// The following should happen very rarely.  We switch to RR.
        if (swap_cnt > 200000) {
            cerr << "LLL_FPInt: swap loop?\n";
            // This one uses large RR matrices rr_* !
            RR_GS(B, B1, mu, b, c, buf, prec, rr_st, k, m_orig, n, rr_B1, rr_mu,
                    rr_b, rr_c);
            if (rr_st < st[k + 1])
                st[k + 1] = rr_st;
            rr_st = k + 1;
            rst = k;
            swap_cnt = 0;
        }
        counter = 0;
        trigger_index = k;
        small_trigger = 0;
        cnt = 0;
        long thresh = 10;
        long sz = 0, new_sz;
        long did_rr_gs = 0;

        do {
            // size reduction
            counter++;
            if ((counter & 127) == 0) {    // Should be 127
                new_sz = 0;
                for (j = 0; j < n; j++)
                    new_sz += NumBits(B[k][j]);
                if ((counter >> 7) == 1 || new_sz < sz) {
                    sz = new_sz;
                } else {
                    cerr << "LLL_FPInt sz = " << sz << " not smaller; infinite loop? \n";
                }
            }
            Fc1 = 0;
            start_over = 0;
            // std::cout << "rst = " << rst << "\n";
            for (j = rst - 1; j >= 0; j--) { // both j and rst are 1 less than in NTL.
                t1 = fabs(mu[k][j]);
                // std::cout << "entered for loop: j =  " <<  j << "  \n";
                // std::cout << "mu[k,j] =  " <<  mu[k][j] << "  t1 =  " <<  t1 << "  \n";
                if (t1 > half_plus_fudge) {
                    // std::cout << "we have t1 > half_plus_fudge, j =  " <<  j << ",  Fc1 = " << Fc1 << "\n";
                    if (!Fc1) {
                        if (j > trigger_index
                                || (j == trigger_index && small_trigger)) {
                            cnt++;
                            if (cnt > thresh) {
                                // std::cout << "ll_LLL FPInt cnt > thresh *** \n";

                                if (log_red <= 15) {
                                    while (log_red > 10)
                                        inc_red_fudge();
                                    half_plus_fudge = 0.5 + red_fudge;
                                    if (!did_rr_gs) {
                                        // This one uses large RR matrices rr_* !
                                        RR_GS(B, B1, mu, b, c, buf, prec, rr_st,
                                                k, m_orig, n, rr_B1, rr_mu,
                                                rr_b, rr_c);
                                        if (rr_st < st[k + 1])
                                            st[k + 1] = rr_st;
                                        rr_st = k + 1;
                                        did_rr_gs = 1;
                                        rst = k;
                                        trigger_index = k;
                                        small_trigger = 0;
                                        start_over = 1;
                                        break;
                                    }
                                } else {
                                    inc_red_fudge();
                                    half_plus_fudge = 0.5 + red_fudge;
                                    cnt = 0;
                                }
                            }
                        }
                        trigger_index = j;
                        small_trigger = (t1 < 4);
                        Fc1 = 1;
                        if (k < rr_st)
                            rr_st = k;
                        // std::cout
                        //       << "ll_LLL FPInt calling RowTransformStart, k = " << k << ",  rr_st = " << rr_st << "\n";
                        RowTransformStart(B1[k], in_vec, in_float, n);
                        // Returns in_float = 1 if all entries of B1[k] are in [-TR_BND, TR_BND].
                    }
                    mu1 = mu[k][j];
                    // std::cout << "Before row transform, mu1 = " << mu1 << " \n";
                    if (mu1 >= 0)
                        mu1 = ceil(mu1 - 0.5);
                    else
                        mu1 = floor(mu1 + 0.5);
                    double *mu_k = mu[k];
                    double *mu_j = mu[j];
                    if (mu1 == 1) {
                        for (i = 0; i < j - 1; i++)
                            mu_k[i] -= mu_j[i];
                    } else if (mu1 == -1) {
                        for (i = 0; i < j - 1; i++)
                            mu_k[i] += mu_j[i];
                    } else {
                        for (i = 0; i < j - 1; i++)
                            mu_k[i] -= mu1 * mu_j[i];
                    }
                    mu_k[j] -= mu1;
                    conv(MU, mu1);
                    // std::cout << "Before row transform, mu1 = " << mu1 << " \n";
                    // We have `in_float=1` if all entries of B1[k] are in [-TR_BND, TR_BND].
                    // The change must be on vector B[k].
                    RowTransform(B[k], B[j], MU, n, B1[k], B1[j], in_vec,
                            max_b[k], max_b[j], in_float);
                    // std::cout << "After row transform, MU = " << MU << " \n";
                    // std::cout << "Basis after row transform: \n" << B << "\n";
                }
            }
            //std::cout << "ll_LLL FPInt before if Fc1 \n";
            if (Fc1) {
                // std::cout << "ll_LLL FPInt inside `if(Fc1)` \n";
                RowTransformFinish(B[k], B1[k], in_vec, n);
                max_b[k] = max_abs(B1[k], n);
                if (!did_rr_gs) {
                    b[k] = InnerProductD(B1[k], B1[k], n);
                    CheckFinite(&b[k]);
                    ComputeGS(B, B1, mu, b, c, k, n, bound, 0, buf);
                    CheckFinite(&c[k]);
                } else {
                    // This one uses large RR matrices !
                    RR_GS(B, B1, mu, b, c, buf, prec, rr_st, k, m_orig, n,
                            rr_B1, rr_mu, rr_b, rr_c);
                    rr_st = k + 1;
                }
                rst = k;
                // std::cout << "After ComputeGS in (Fc1), rst = " << rst << ",  max_b[k]= "
                //     << max_b[k] << ", did_rr_gs=  " << did_rr_gs << ", b[k]=  " << b[k] << "\n";
                // std::cout << "After ComputeGS in (Fc1), mu[k] = " << mu[k][0] << "  " << mu[k][1] << "  " << mu[k][2] << "  " << mu[k][3] << "\n";
            }
            // std::cout << "End of loop, B = " <<  B << "  \n";
        } while (Fc1 || start_over);  // end do loop

        // std::cout << "ll_LLL FPInt after while Fc1, k = " << k << "  b[k] = " << b[k] << "\n";
        // std::cout << "Basis after while Fc1 \n" << B << "\n";
        if (b[k] == 0) {
            for (i = k; i < m - 1; i++) {
                // swap i, i+1
                swap(B[i], B[i + 1]);
                tp = B1[i];
                B1[i] = B1[i + 1];
                B1[i + 1] = tp;
                t1 = b[i];
                b[i] = b[i + 1];
                b[i + 1] = t1;
                t1 = max_b[i];
                max_b[i] = max_b[i + 1];
                max_b[i + 1] = t1;
            }
            for (i = k; i <= m + 1; i++)
                st[i] = 1;
            if (k < rr_st)
                rr_st = k;
            m--;
            continue;
        }
        // std::cout << "ll_LLL FPInt before test LLL condition \n";
// test LLL reduction condition
        if (k > 0
                && delta * c[k - 1]
                        > c[k] + mu[k][k - 1] * mu[k][k - 1] * c[k - 1]) {
            // swap rows k, k-1
            swap(B[k], B[k - 1]);
            tp = B1[k];
            B1[k] = B1[k - 1];
            B1[k - 1] = tp;
            tp = mu[k];
            mu[k] = mu[k - 1];
            mu[k - 1] = tp;
            t1 = b[k];
            b[k] = b[k - 1];
            b[k - 1] = t1;
            t1 = max_b[k];
            max_b[k] = max_b[k - 1];
            max_b[k - 1] = t1;
            k--;
            NumSwaps++;
            swap_cnt++;
            // cout << "-\n";
        } else {
            k++;
            // cout << "+\n";
        }
    }
    return m;
}

template<typename IntMat>
static long LLL_FPInt(IntMat &B, double delta, long m, long n, Vec<double>* sqlen) {
    if (m == 0)
        m = B.NumRows();
    if (n == 0)
        n = B.NumCols();
    RR_GS_time = 0;
    NumSwaps = 0;
    if (delta < 0.50 || delta >= 1)
        LogicError("LLL_FP: bad delta");
    long i, j;
    long new_m;
    init_red_fudge();

    Unique2DArray<double> B1_store;
    B1_store.SetDims(m, n);
    double **B1 = B1_store.get();  // approximates B by a matrix of `double`

    Unique2DArray<double> mu_store;
    mu_store.SetDims(m, m);
    double **mu = mu_store.get();

    UniqueArray<double> c_store;
    c_store.SetLength(m);
    double *c = c_store.get(); // squared lengths of Gramm-Schmidt basis vectors

    UniqueArray<double> b_store;
    b_store.SetLength(m + 1);
    double *sqlen2 = b_store.get(); // squared lengths of basis vectors
    // This sqlen2 is usually the same as sqlen, but we have to do this
    // because we are not sure how much space has been reserved for sqlen.
    // and we do not want to change the pointer sqlen that is passed!

    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++) {
            conv(B1[i][j], B[i][j]);  // Converts from Int to double
            CheckFinite(&B1[i][j]);
        }
    for (i = 0; i < m; i++) {
        sqlen2[i] = InnerProductD(B1[i], B1[i], n);  // Square norms in double.
        CheckFinite(&sqlen2[i]);
    }
    // std::cout << "LLL FPInt before ll_LLL  \n";
    // Indices in sqlen and B1 start at 0, which is 1 less than in NTL.
    new_m = ll_LLL_FP(B, delta, B1, mu, sqlen2, c, m, n, 0);
    // std::cout << "LLL FPInt after ll_LLL  \n";

    // In this version, we leave the zero rows at the bottom.
    // The new_m independent basis vectors will be at the top of `B`.
    // Put shortest nonzero vector in first place.
    long imin = 0;
    double minSqlen = sqlen2[0];
    for (i = 1; i < new_m; i++)
        if (sqlen2[i] < minSqlen) {
            minSqlen = sqlen2[i];
            imin = i;
        };
    if (imin > 0) {
        NTL::swap(B[0], B[imin]);
        std::swap(sqlen2[0], sqlen2[imin]);
    }
    if (sqlen) {
        if (sqlen->length() < new_m) sqlen->SetLength(new_m);
        for (i = 0; i < new_m; i++)  (*sqlen)[i] = sqlen2[i];
    }
    // std::cout << "In LLL FPInt after the swaps:  ";
    // std::cout << "sqlen2[0] = " << sqlen2[0] << "\n";
    // std::cout << "Inside LLL, after swaps: sqlen[0] = " << sqlen[0] << "\n";
    return new_m;
}

//  BKZ   =====================================================================

static vec_double BKZConstant;

static void ComputeBKZConstant(long beta, long p) {
    const double c_PI = 3.14159265358979323846264338328;
    const double LogPI = 1.14472988584940017414342735135;

    BKZConstant.SetLength(beta - 1);   // Index starts at 0.
    vec_double Log;
    Log.SetLength(beta);
    long i, j, k;
    double x, y;

    for (i = 1; i <= beta; i++)
        Log[i - 1] = log(double(i));
    for (i = 1; i <= beta - 1; i++) {
// First, we compute x = gamma(i/2)^{2/i}
        k = i / 2;
        if ((i & 1) == 0) { // i even
            x = 0;
            for (j = 1; j <= k; j++)
                x = x + Log[j - 1];
            x = x * (1 / double(k));
            x = exp(x);
        } else { // i odd
            x = 0;
            for (j = k + 2; j <= 2 * k + 2; j++)
                x = x + Log[j - 1];
            x = 0.5 * LogPI + x - 2 * (k + 1) * Log[1];  // ln 2
            x = x * (2.0 / double(i));
            x = exp(x);
        }
// Second, we compute y = 2^{2*p/i}
        y = -(2 * p / double(i)) * Log[1];
        y = exp(y);
        BKZConstant[i - 1] = x * y / c_PI;
    }
}

static vec_double BKZThresh;

static
void ComputeBKZThresh(double *c, long beta) {
    BKZThresh.SetLength(beta - 1);
    long i;
    double x;
    x = 0;
    for (i = 0; i < beta - 1; i++) {
        x += log(c[i]);
        BKZThresh[i] = exp(x / double(i + 1)) * BKZConstant[i];
        if (!IsFinite(&BKZThresh[i]))
            BKZThresh[i] = 0;
    }
}

template<typename IntMat>
static
void BKZStatus(double tt, double enum_time, unsigned long NumIterations,
        unsigned long NumTrivial, unsigned long NumNonTrivial,
        unsigned long NumNoOps, long m, long n, const IntMat &B) {
    cerr << "---- BKZ_FPZZ status ----\n";
    cerr << "elapsed time: ";
    PrintTime(cerr, tt - StartTime);
    cerr << ", enum time: ";
    PrintTime(cerr, enum_time);
    cerr << ", iter: " << NumIterations << "\n";
    cerr << "triv: " << NumTrivial;
    cerr << ", nontriv: " << NumNonTrivial;
    cerr << ", no ops: " << NumNoOps;
    cerr << ", rank: " << m;
    cerr << ", swaps: " << NumSwaps << "\n";
    Int t1;
    long i;
    double prodlen = 0;
    for (i = 0; i < m; i++) {
        InnerProductV(t1, B[i], B[i], n);   // All in Int
        if (!IsZero(t1))
            prodlen += log(t1);
    }
    cerr << "log of prod of lengths: " << prodlen / (2.0 * log(2.0)) << "\n";
    if (LLLDumpFile) {
        cerr << "dumping to " << LLLDumpFile << "...";
        ofstream f;
        OpenWrite(f, LLLDumpFile);
        f << "[";
        for (i = 0; i < m; i++) {
            f << B[i] << "\n";
        }
        f << "]\n";
        f.close();
        cerr << "\n";
    }
    LastTime = tt;
}

template<typename IntMat>
static long BKZ_FPInt(IntMat &BB, double delta, long beta, long prune, long m, long n,
        Vec<double>* sqlen) {
    if (m == 0)
        m = BB.NumRows();
    if (n == 0)
        n = BB.NumCols();
    RR_GS_time = 0;
    NumSwaps = 0;
    if (delta < 0.50 || delta >= 1)
        LogicError("BKZ_FPZZ: bad delta");
    if (beta < 2)
        LogicError("BKZ_FPZZ: bad block size");
    long m_orig = m;
    long i, j;
    Int MU;
    double t1;
    double *tp;
    init_red_fudge();

    IntMat B;    // Will be a copy of BB, with one more row.   ********
    // Change it to smaller dimensions.
    B.SetDims(m + 1, n);
    for (i = 0; i <= m; i++) {
        for (j = 0; j < n; j++) {
            B[i][j] = BB[i][j];
        }
    }
    Unique2DArray<double> B1_store;
    B1_store.SetDims(m + 1, n);
    double **B1 = B1_store.get();  // approximates B

    Unique2DArray<double> mu_store;
    mu_store.SetDims(m + 1, m);
    double **mu = mu_store.get();

    UniqueArray<double> c_store;
    c_store.SetLength(m + 1);
    double *c = c_store.get(); // squared lengths of Gramm-Schmidt basis vectors

    UniqueArray<double> b_store;
    b_store.SetLength(m + 1);
    double *b = b_store.get(); // squared lengths of basis vectors

    double cbar;

    UniqueArray<double> ctilda_store;
    ctilda_store.SetLength(m + 1);
    double *ctilda = ctilda_store.get();

    UniqueArray<double> vvec_store;
    vvec_store.SetLength(m + 1);
    double *vvec = vvec_store.get();

    UniqueArray<double> yvec_store;
    yvec_store.SetLength(m + 1);
    double *yvec = yvec_store.get();

    UniqueArray<double> uvec_store;
    uvec_store.SetLength(m + 1);
    double *uvec = uvec_store.get();

    UniqueArray<double> utildavec_store;
    utildavec_store.SetLength(m + 1);
    double *utildavec = utildavec_store.get();

    UniqueArray<long> Deltavec_store;
    Deltavec_store.SetLength(m + 1);
    long *Deltavec = Deltavec_store.get();

    UniqueArray<long> deltavec_store;
    deltavec_store.SetLength(m + 1);
    long *deltavec = deltavec_store.get();

    long new_m;
    long z, jj, kk;
    long s, t;
    long h;
    long eta;
    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++) {
            conv(B1[i][j], B[i][j]);
            CheckFinite(&B1[i][j]);
        }
    for (i = 0; i < m; i++) {
        b[i] = InnerProductD(B1[i], B1[i], n);
        CheckFinite(&b[i]);
    }
    m = ll_LLL_FP(B, delta, B1, mu, b, c, m, n, 0);

    // double tt;
    // double enum_time = 0;
    unsigned long NumIterations = 0;
    unsigned long NumTrivial = 0;
    unsigned long NumNonTrivial = 0;
    unsigned long NumNoOps = 0;
    long clean = 1;

    if (m < m_orig) {
        for (i = m_orig; i >= m + 1; i--) {
            // swap i, i-1
            swap(B[i], B[i - 1]);
        }
    }
    if (m > 1) {
        if (beta > m)
            beta = m;
        if (prune > 0)
           ComputeBKZConstant(beta, prune);
        z = 0;
        jj = 0;
        while (z < m - 1) {
            jj++;
            kk = min(jj + beta - 2, m - 1);
            if (jj == m) {
                jj = 1;
                kk = beta - 1;
                clean = 1;
            }
            if (prune > 0)
                ComputeBKZThresh(&c[jj], kk-jj+1);
            cbar = c[jj];
            utildavec[jj] = uvec[jj] = 1;
            yvec[jj] = vvec[jj] = 0;
            Deltavec[jj] = 0;
            s = t = jj;
            deltavec[jj] = 1;
            for (i = jj; i <= kk + 1; i++) {
                ctilda[i] = uvec[i] = utildavec[i] = yvec[i] = 0;
                Deltavec[i] = 0;
                vvec[i] = 0;
                deltavec[i] = 1;
            }
            // long enum_cnt = 0;
            while (t <= kk) {
                ctilda[t] = ctilda[t + 1]
                        + (yvec[t] + utildavec[t]) * (yvec[t] + utildavec[t])
                                * c[t];
                ForceToMem(&ctilda[t]);  // prevents an infinite loop
                if (prune > 0 && t > jj)
                    eta = BKZThresh(t-jj);
                else
                    eta = 0;
                if (ctilda[t] < cbar - eta) {
                    if (t > jj) {
                        t--;
                        t1 = 0;
                        for (i = t + 1; i <= s; i++)
                            t1 += utildavec[i] * mu[i][t];
                        yvec[t] = t1;
                        t1 = -t1;
                        if (t1 >= 0)
                            t1 = ceil(t1 - 0.5);
                        else
                            t1 = floor(t1 + 0.5);
                        utildavec[t] = vvec[t] = t1;
                        Deltavec[t] = 0;
                        if (utildavec[t] > -yvec[t])
                            deltavec[t] = -1;
                        else
                            deltavec[t] = 1;
                    } else {
                        cbar = ctilda[jj];
                        for (i = jj; i <= kk; i++) {
                            uvec[i] = utildavec[i];
                        }
                    }
                } else {
                    t++;
                    s = max(s, t);
                    if (t < s)
                        Deltavec[t] = -Deltavec[t];
                    if (Deltavec[t] * deltavec[t] >= 0)
                        Deltavec[t] += deltavec[t];
                    utildavec[t] = vvec[t] + Deltavec[t];
                }
            }
            NumIterations++;
            h = min(kk, m - 1);
            if ((delta - 8 * red_fudge) * c[jj] > cbar) {
                clean = 0;
                // we treat the case that the new vector is b_s (jj < s <= kk)
                // as a special case that appears to occur most of the time.
                s = 0;
                for (i = jj + 1; i <= kk; i++) {
                    if (uvec[i] != 0) {
                        if (s == 0)
                            s = i;
                        else
                            s = -1;
                    }
                }
                if (s == 0)
                    LogicError("BKZ_FPZZ: internal error, s==0.");
                if (s > 0) {
                    // special case
                    NumTrivial++;
                    for (i = s - 1; i >= jj; i--) {
                        // swap i, i-1
                        swap(B[i - 1], B[i]);
                        tp = B1[i - 1];
                        B1[i - 1] = B1[i];
                        B1[i] = tp;
                        t1 = b[i - 1];
                        b[i - 1] = b[i];
                        b[i] = t1;
                    }
                    // cerr << "special case\n";
                    new_m = ll_LLL_FP(B, delta, B1, mu, b, c, h, n, jj);
                    if (new_m != h)
                        LogicError("BKZ_FPZZ: internal error");
                } else {
                    // the general case
                    NumNonTrivial++;
                    for (i = 0; i < n; i++)
                        conv(B[m][i], 0);
                    for (i = jj; i <= kk; i++) {
                        if (uvec[i] == 0)
                            continue;
                        conv(MU, uvec[i]);
                        RowTransformAdd(B[m], B[i], MU, n);
                    }
                    for (i = m; i >= jj + 1; i--) {
                        // swap i, i-1
                        swap(B[i - 1], B[i]);
                        tp = B1[i - 1];
                        B1[i - 1] = B1[i];
                        B1[i] = tp;
                        t1 = b[i - 1];
                        b[i - 1] = b[i];
                        b[i] = t1;
                    }
                    for (i = 0; i < n; i++) {
                        conv(B1[jj][i], B[jj - 1][i]);  //  ??????
                        CheckFinite(&B1[jj][i]);
                    }
                    b[jj] = InnerProductD(B1[jj], B1[jj], n);
                    CheckFinite(&b[jj]);
                    if (b[jj] == 0)
                        LogicError("BKZ_FPInt: internal error, b[jj]==0");

                    // remove linear dependencies
                    // cerr << "general case\n";
                    new_m = ll_LLL_FP(B, delta, B1, mu, b, c, kk + 1, n, jj);
                    if (new_m != kk)
                        LogicError("BKZ_FPInt: internal error, new_m != kk");
                    // remove zero vectors
                    for (i = kk + 1; i <= m; i++) {
                        // swap i, i-1
                        swap(B[i - 1], B[i]);
                        tp = B1[i - 1];
                        B1[i - 1] = B1[i];
                        B1[i] = tp;
                        t1 = b[i - 1];
                        b[i - 1] = b[i];
                        b[i] = t1;
                    }
                    if (h > kk) {
                        // extend reduced basis
                        new_m = ll_LLL_FP(B, delta, B1, mu, b, c, h + 1, n, h);
                        if (new_m != h + 1)
                            LogicError("BKZ_FPInt: internal error, new_m != h");
                    }
                }
                z = 0;
            } else {
                NumNoOps++;
                if (!clean) {
                    new_m = ll_LLL_FP(B, delta, B1, mu, b, c, h + 1, n, h);
                    if (new_m != h + 1)
                        LogicError("BKZ_FPInt: internal error, new_m != h");
                }
                z++;
            }
        }
    }
// In this version, we do not move the zero vectors to the top.
// We also do not change the dimensions of BB.
    for (i = 0; i < m_orig; i++) {
        for (j = 0; j < n; j++) {
            BB[i][j] = B[i][j];
        }
    }
// Put the shortest nonzero vector in first place.
    long imin = 0;
    double minlen = b[0];
    for (i = 1; i < m; i++)
        if (b[i] < minlen) {
            minlen = b[i];
            imin = i;
        };
    if (imin > 0) {
        swap(BB[0], BB[imin]);
        std::swap(b[1], b[imin]);
    }
    if (sqlen) {
        if (sqlen->length() < m) sqlen->SetLength(m);
        for (i = 0; i < m; i++)
            (*sqlen)[i] = b[i];
    }
    return m;    // Number of rows in basis.
}

NTL_END_IMPL

#endif
