/**
 * 
 * \if NESTED_PROJECT
 * \page latticetester LatticeTester Manual
 * \else
 * \mainpage LatticeTester Manual
 * \endif
 * 
 * # Reference Manual
 * 
 * This is the reference manual of [LatticeTester](https://github.com/umontreal-simul/latticetester),
 * a library intented to simplify the construction of software studying lattices.
 *
 * ### Manual Outline
 * 
 * The manual includes the following sections
 * - This introduction page, describing the capabilities of *LatticeTester*
 * - \subpage examples_page that every beginner should look at to familiarize
 *   itself with usage of the main classes of the library
 * - \subpage a_intro presenting the unknowledgeable user with enough theoretical
 *   background to get started
 * - \subpage detailed_usage presenting the installation process (the
 *   dependencies and the compilation process) and the usage of an executable
 *   bundled with *LatticeTester* to perform high-level use of the library.
 * 
 * This manual also include a full API documentation automatically generated by
 * Doxygen. It is available through the "Classes" and "Namespaces" buttons above.
 * Finally, *LatticeTester* is open source software distributed with a licence
 * available on [Github](https://github.com/umontreal-simul/latticetester).
 *
 * # Overview
 * 
 * *LatticeTester* is a C++ library to perform various computations on
 * lattices \f$L_t\f$ in the \f$t\f$-dimensional rational space. Lattices are
 * discrete subgroups of a vector space (generally, the set of all integer
 * combinations of a basis of said vector space) encountered, as an example, in
 * the analysis of quasi-Monte Carlo point sets and certain kinds of
 * pseudo-random number generators.
 *
 * *LatticeTester* can perform most of its operations either on the **lattice**
 * spanned by \f$v_1, \ldots, v_s \in \mathbb{Q}^t\f$,
 * \f$L_t = \{\sum_{i=1}^s a_i v_i \ | \ a_i \in \mathbb{Z}\}\f$,
 * or its <b>m-dual lattice</b>,
 * \f$mL_t^* = \{w \ | \ w \cdot v \in m\mathbb{Z}, \ \forall v \in L_t\}\f$.
 * To do so, lattices are stored as a **basis**, a minimal (of cardinality \f$t\f$
 * set of generating
 * vectors \f$\{v_1, \ldots, v_t\} \in L_t\f$, rescalled to only have integer
 * coordinates. Vectors are stored as integer so that all the computations are
 * done exactly on the lattice. <b><i>LatticeTester</i> only accepts integer
 * lattices and
 * lattices need to be rescalled before being given as input.</b> Note that
 * \f$mL_t^*\f$ is also stored as integer vectors. In fact, \f$m\f$ is choosen
 * so that \f$L_t^* \subset \mathbb{Q}^t\f$ becomes \f$mL_t^* \subset\mathbb{Z}^t\f$.
 *
 * The main goal of this library is to implements and/or facilitate the
 * computation of theoretical measure of uniformity (or figures of merit) on
 * lattices, as it is the main concern when studying pseudo-random point sets
 * \cite rKNU81a\cite rNIE92b. To perform these algorithms efficiently,
 * *LatticeTester* also implements a handfull of handy lattices manipulations:
 * 1. **Lattice Basis Construction**: Given a set of vectors that are not
 * necessarily independent but span a lattice, find a basis for that lattice.
 * 2. **Dual Lattice Basis construction**: Given a lattice basis for \f$L_t\f$,
 * compute the corresponding m-dual lattice basis for \f$mL_t^*\f$ whether \f$m\f$
 * is known or not.
 * 3. **Lattice Basis Reduction**: Given a lattice basis, find another basis
 * whose vectors are nearly orthogonal or as short as possible.
 * There are many variants and definitions for this, such as the well known LLL
 * reduction for which an algorithm is available.
 * 4. **Shortest Vector computation**: Find the shortest non-zero vector in a
 * lattice, and prove it is the shortest.
 *
 * The measures of uniformity that are considered by this software are the
 * spectral test, that is the inverse length of the shortest vector in the
 * dual lattie, and the Beyer ratio, which is an old test (\cite rBEY71a)
 * inlcuded mainly as part of our legacy code base. Building on those mesures
 * of uniformity, *LatticeTester* also implements classes to build __figures of
 * merit__ upon them. Figures of merit are a recurring theme in quasi-Monte
 * Carlo point set studies \cite vLEC12a. A figure of merit is a standardized
 * measure that can be used to compare point sets between them. Generally,
 * they are constructed as a weighted sum, or the minimum of weighted values : 
 * \f[
 *      \min_{i \subset I} \omega_i \ell_i
 * \f]
 * with \f$I\f$, a set of indices, \f$\omega_i\f$ being weights and \f$\ell_i\f$
 * a mesure on the projection of a lattice on set of indices \f$i\f$.
 *
 * Finaly, for the sake of convenience, *LatticeTester* also features a
 * high-level executable that can perform, without much flexibility, some of the
 * computations featured in *LatticeTester*. Its usage is described in \ref detailed_usage
 *
 * *LatticeTester* is not intended as a tool to search for lattices that conform
 * to certain prerequisites, but instead it can be extended with a few classes
 * to do so. <b>[LatNet Builder](https://github.com/umontreal-simul/latnetbuilder)</b>
 * and <b>[LatMRG](https://github.com/umontreal-simul/latmrg)</b> are software
 * tools designed in our laboratory that are examples of the capabilities of
 * this library. The first one is designed to analyze and search for lattice
 * rules for quasi-Monte-Carlo integration whilst the second does something similar
 * for linear congruential pseudo-random number generators.
 *
 * In the next section, you will find a detailled list of what is implemented in
 * *LatticeTester*, along with links to the relevant parts of the API
 * documentation. Users wishing to quickly "get their hands dirty" in this
 * library are advised to skip the next section and to go to the \ref examples_page.
 * 
 * # Contents and implementation
 * 
 * This project is mostly built as an object oriented library. The following
 * describes the contents of the library and gives the names of the classes
 * performing them. This is essentially a lenghtier version of the section
 * above containing "from the ground up" explanations of the library contents,
 * starting from lattice representation and going to the construction of basic
 * figures of merit. While goind through the functionnalities of *LatticeTester*
 * this section will also mention every tool needed to access these functions.
 *
 * \remark This section assumes the reader is familiar with a bit of lattice
 * specific vocabulary. We have two options (I prefer the second one):
 * - Have explanations here of every thing mentionned and keep \ref a_intro as a
 *   more advanced ressource
 * - Only use \ref a_intro as our only theorethical guide.
 *
 * ## Types and representations
 *
 * Before diving into the features of *LatticeTester* lets look at what are NOT
 * features of this library, but are needed by it: the ability to manipulate
 * numbers of arbitrary size with decent efficiency. To do that, we use another
 * library called the Number Theory Library, more commonly called NTL. Anyone
 * using *LatticeTester* will need to use some of the functionnalities of NTL
 * at one point. Many basic mathematical functions require using this library
 * directly. Its documentation can be found at [https://www.shoup.net/ntl/](https://www.shoup.net/ntl/).
 * Note that this documentation also contains a namespace called NTL. This
 * namespace contains extentions of NTL functions to non-NTL types to ease the
 * usage of *LatticeTester* with NTL and non-NTL types with the same code.
 *
 * As its name says, *LatticeTester* is a library to manipulate lattices. As
 * such, it implements classes representing lattices. First there is the
 * `IntLatticeBasis` class that simply is a class to represent a lattice basis
 * by storing a matrix. This class can exchange the order of the vectors in the basis,
 * compute their norm and also store the dual basis. Most functions doing
 * computations on lattices directly use either the basis matrix or this class.
 * it is recommended to use this class to represent lattices when working
 * exclusively with *LatticeTester*. This is what is done in the \ref examples_page.
 *
 * When using the library with a specific problem in mind, more powerful objects
 * representing lattices can be obtained by using the problem structure to
 * build a lattice and different projections easily. For this use case, we
 * provide the `IntLattice` class. This class inherits `IntLatticeBasis` to be
 * used with the library easily and contains lattice specific features and
 * virtual methods. These ad the possibility to build projections
 * for the lattice and to build a basis for different dimensions. These features
 * are not immediately useful here: a lattice cannot change dimension, but, for
 * example, an random number generator may span a lattice in multiple dimensions
 * and implementing these methods can be a good way to build them sequentially
 * with a single object.
 *
 * ## Library features
 *
 * As presented above, *LatticeTester* revolves around solving 4 different
 * problems. We now present what is available to resolve them with a bit more
 * specificity. For a more hands-on approach than this section, the
 * \ref examples_page are the place to go.
 *
 * ### Basis construction
 * 
 * *LatticeTester* can build the basis of a lattice from a set of generating
 * vectors. That is, given a set of vectors
 * \f$\{v_1, \ldots, v_s\} \in \mathbb{Z}^t\f$
 * spanning a lattice \f$L_t\f$, it can extract another set of vectors
 * \f$\{\hat{v}_1, \ldots, \hat{v}_t\}\f$ that is a basis of the lattice.
 * There are two methods available to do just that in the `BasisConstruction`
 * class. Beyond this basic functionnality that most users will probably not
 * even need, *LatticeTester* also has ways to build projections of a lattice,
 * which is a much more desirable feature.
 *
 * To build a projection what is usually done is to take a subset of the
 * coordinates \f$\{1, \ldots, t\}\f$ of the lattice vectors and to only consider
 * the vectors formed by this subset of coordinates. 
 *
 * \todo Remove bellow.
 *
 * The prefered approach to solving the problems above is presented in the
 * reference
 * manual. For each of the problems, *LatticeTester* implements at least one way
 * to solve it. For 1, a simple approach based on Gaussian elimination is
 * available. There is also a method that performs 3. via LLL reduction at the
 * same time. Although 2 is, most of the time, application specific, there is
 * a general function allowing to compute the dual basis of a integer lattice
 * as well as the rescalling needed for the dual to be integer. 1 and 2 being
 * somewhat simple problems, they are covered entirely in the reference manual.
 * *LatticeTester* implements 4 solutions to 3:
 * - **Dieter pre-reduction** given by Dieter in \cite rDIE75a.
 * - **LLL reduction** given Lenstra, Lenstra and Lovasz in \cite mLEN82a.
 * - **Block Korkin-Zolotarev (BKZ)** reduction given by Schnorr \cite mSCH91a.
 * - **Reduction in the sense of Minkowski** given by Minkowski in \cite mMIN11a.
 *
 * Next, 4 can be solved via a Branch and Bound algorithm that is available for
 * both the euclidian and the L1 norms. This algorithm is the one proposed in
 * \cite rDIE75a and later improved in \cite rKNU98a and \cite mFIN85a. Finally,
 * 5 is not yet implemented or is not implemented in any interesting way.
 *
 * The figures of merit strongly depend on the other problems. The
 * implementation of the Spectral Test, given originally by Coveyou and
 * MacPherson \cite rCOV67a, and improved by Knuth \cite rKNU98a requires an
 * algorithm solving the shortest vector problem (4). It is also traditionally
 * done on the dual of the lattice instead of the primal. The Beyer ratio is
 * dependant on the Branch and Bound procedure: it implements a variant of the
 * Branch and Bound process in order to perform a Minkowski reduction
 * \cite mMIN11a \cite rAFF85a.
 *
 * The computing time of the Branch and Bound procedure depends exponentially on
 * the dimension for which we want to solve it. But it also significantly
 * depends on the length of the vectors in the input basis. It turns out that
 * the shortest the input vectors are (i.e the more the input basis is already
 * reduced), the fastest the branch and bound will be performed. Hence, it is
 * also recommended to perform a basis reduction before the figures of merit
 * computation to prevent an explosion of the computing time.
 * 
 * When doing the spectral test, the shortest vector given by the Branch and
 * Bound shall be compared to an upper bound on its length. *LatticeTester*
 * proposes several normalization based on the sphere packing problem given in
 * \cite mCON99a.
 * 
 * The vast majority - and more specifically LLL and BKZ reduction - of the
 * implementation is based on the NTL library developped by Victor Shoup
 * \cite iSHO05a. It is based itself on the GNU Multiple Precision Arithmetic
 * Library (GMP) \cite iGMP06a, which allow arbitrary precision for
 * calculations.
 * 
 * 
 * */
