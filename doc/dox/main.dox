/**
 * 
 * \if NESTED_PROJECT
 * \page latticetester LatticeTester Manual
 * \else
 * \mainpage LatticeTester Manual
 * \endif
 * 
 * # Reference Manual
 * 
 * This is the reference manual of [LatticeTester](https://github.com/umontreal-simul/latticetester),
 * a library intented to simplify the construction of software studying lattices.
 *
 * ### Manual Outline
 * 
 * The manual includes the following sections
 * - This introduction page, describing the capabilities of *LatticeTester*
 * - \subpage examples_page that every beginner should look at to familiarize
 *   itself with usage of the main classes of the library
 * - \subpage a_intro presenting the unknowledgeable user with enough theoretical
 *   background to get started
 * - \subpage detailed_usage presenting the installation process (the
 *   dependencies and the compilation process) and the usage of an executable
 *   bundled with *LatticeTester* to perform high-level use of the library.
 * 
 * This manual also include a full API documentation automatically generated by
 * Doxygen. It is available through the "Classes" and "Namespaces" buttons above.
 * Finally, *LatticeTester* is open source software distributed with a licence
 * available on [Github](https://github.com/umontreal-simul/latticetester).
 *
 * # Overview
 * 
 * *LatticeTester* is a C++ library to perform various computations on
 * lattices \f$L_t\f$ in the \f$t\f$-dimensional rational space. Lattices are
 * discrete subgroups of a vector space (generally, the set of all integer
 * combinations of a basis of said vector space) encountered, as an example, in
 * the analysis of quasi-Monte Carlo point sets and certain kinds of
 * pseudo-random number generators.
 *
 * *LatticeTester* can perform most of its operations either on the **lattice**
 * spanned by \f$v_1, \ldots, v_s \in \mathbb{Q}^t\f$,
 * \f$L_t = \{\sum_{i=1}^s a_i v_i \ | \ a_i \in \mathbb{Z}\}\f$,
 * or its <b>m-dual lattice</b>,
 * \f$mL_t^* = \{w \ | \ w \cdot v \in m\mathbb{Z}, \ \forall v \in L_t\}\f$.
 * To do so, lattices are stored as a **basis**, a minimal (of cardinality \f$t\f$
 * set of generating
 * vectors \f$\{v_1, \ldots, v_t\} \in L_t\f$, rescalled to only have integer
 * coordinates. Vectors are stored as integer so that all the computations are
 * done exactly on the lattice. <b><i>LatticeTester</i> only accepts integer
 * lattices and
 * lattices need to be rescalled before being given as input.</b> Note that
 * \f$mL_t^*\f$ is also stored as integer vectors. In fact, \f$m\f$ is choosen
 * so that \f$L_t^* \subset \mathbb{Q}^t\f$ becomes \f$mL_t^* \subset\mathbb{Z}^t\f$.
 *
 * The main goal of this library is to implements and/or facilitate the
 * computation of theoretical measure of uniformity (or figures of merit) on
 * lattices, as it is the main concern when studying pseudo-random point sets
 * \cite rKNU81a\cite rNIE92b. To perform these algorithms efficiently,
 * *LatticeTester* also implements a handfull of handy lattices manipulations:
 * 1. **Lattice Basis Construction**: Given a set of vectors that are not
 * necessarily independent but span a lattice, find a basis for that lattice.
 * 2. **Dual Lattice Basis construction**: Given a lattice basis for \f$L_t\f$,
 * compute the corresponding m-dual lattice basis for \f$mL_t^*\f$ whether \f$m\f$
 * is known or not.
 * 3. **Lattice Basis Reduction**: Given a lattice basis, find another basis
 * whose vectors are nearly orthogonal or as short as possible.
 * There are many variants and definitions for this, such as the well known LLL
 * reduction for which an algorithm is available.
 * 4. **Shortest Vector computation**: Find the shortest non-zero vector in a
 * lattice, and prove it is the shortest.
 *
 * The measures of uniformity that are considered by this software are the
 * spectral test, that is the inverse length of the shortest vector in the
 * dual lattie, and the Beyer ratio, which is an old test (\cite rBEY71a)
 * inlcuded mainly as part of our legacy code base. Building on those mesures
 * of uniformity, *LatticeTester* also implements classes to build __figures of
 * merit__ upon them. Figures of merit are a recurring theme in quasi-Monte
 * Carlo point set studies \cite vLEC12a. A figure of merit is a standardized
 * measure that can be used to compare point sets between them. Generally,
 * they are constructed as a weighted sum, or the minimum of weighted values : 
 * \f[
 *      \min_{i \subset I} \omega_i \ell_i
 * \f]
 * with \f$I\f$, a set of indices, \f$\omega_i\f$ being weights and \f$\ell_i\f$
 * a mesure on the projection of a lattice on set of indices \f$i\f$.
 *
 * Finaly, for the sake of convenience, *LatticeTester* also features a
 * high-level executable that can perform, without much flexibility, some of the
 * computations featured in *LatticeTester*. Its usage is described in \ref detailed_usage
 *
 * *LatticeTester* is not intended as a tool to search for lattices that conform
 * to certain prerequisites, but instead it can be extended with a few classes
 * to do so. <b>[LatNet Builder](https://github.com/umontreal-simul/latnetbuilder)</b>
 * and <b>[LatMRG](https://github.com/umontreal-simul/latmrg)</b> are software
 * tools designed in our laboratory that are examples of the capabilities of
 * this library. The first one is designed to analyze and search for lattice
 * rules for quasi-Monte-Carlo integration whilst the second does the same thing
 * for linear congruential pseudo-random number generators.
 *
 * In the next section, you will find a detailled list of what is implemented in
 * *LatticeTester*, along with links to the relevant parts of the API
 * documentation. Users wishing to quickly "get their hands dirty" in this
 * library are advised to skip the next section and to go to the \ref examples_page.
 * 
 * # Contents and implementation
 * 
 * To do what has been advertised above, *LatticeTester* implements a few key
 * features as classes. This project is mostly built as an object oriented
 * library, and related functions have been grouped in classes to be easy to
 * find. Bellow, you will find a "from the ground up" explanation of the classes
 * contained in *LatticeTester*, that is: we will explain features of
 * *LatticeTester* from the most basic ones to the more complex ones and we will
 * link them to the relevant classes. 
 *
 * Before diving into the features of *LatticeTester* lets look at what are NOT
 * features of this library, but are needed by it: the ability to manipulate
 * numbers of arbitrary size with decent efficiency. To do that, we use another
 * library called the Number Theory Library, more commonly called NTL. Anyone
 * using *LatticeTester* will need to use some of the functionnalities of NTL
 * at one point. Many basic mathematical functions require using this library
 * directly. Its documentation can be found at [https://www.shoup.net/ntl/](https://www.shoup.net/ntl/)
 *
 * \todo Remove bellow.
 * The prefered approach to solving the problems above is presented in the
 * reference
 * manual. For each of the problems, *LatticeTester* implements at least one way
 * to solve it. For 1, a simple approach based on Gaussian elimination is
 * available. There is also a method that performs 3. via LLL reduction at the
 * same time. Although 2 is, most of the time, application specific, there is
 * a general function allowing to compute the dual basis of a integer lattice
 * as well as the rescalling needed for the dual to be integer. 1 and 2 being
 * somewhat simple problems, they are covered entirely in the reference manual.
 * *LatticeTester* implements 4 solutions to 3:
 * - **Dieter pre-reduction** given by Dieter in \cite rDIE75a.
 * - **LLL reduction** given Lenstra, Lenstra and Lovasz in \cite mLEN82a.
 * - **Block Korkin-Zolotarev (BKZ)** reduction given by Schnorr \cite mSCH91a.
 * - **Reduction in the sense of Minkowski** given by Minkowski in \cite mMIN11a.
 *
 * Next, 4 can be solved via a Branch and Bound algorithm that is available for
 * both the euclidian and the L1 norms. This algorithm is the one proposed in
 * \cite rDIE75a and later improved in \cite rKNU98a and \cite mFIN85a. Finally,
 * 5 is not yet implemented or is not implemented in any interesting way.
 *
 * The figures of merit strongly depend on the other problems. The
 * implementation of the Spectral Test, given originally by Coveyou and
 * MacPherson \cite rCOV67a, and improved by Knuth \cite rKNU98a requires an
 * algorithm solving the shortest vector problem (4). It is also traditionally
 * done on the dual of the lattice instead of the primal. The Beyer ratio is
 * dependant on the Branch and Bound procedure: it implements a variant of the
 * Branch and Bound process in order to perform a Minkowski reduction
 * \cite mMIN11a \cite rAFF85a.
 *
 * The computing time of the Branch and Bound procedure depends exponentially on
 * the dimension for which we want to solve it. But it also significantly
 * depends on the length of the vectors in the input basis. It turns out that
 * the shortest the input vectors are (i.e the more the input basis is already
 * reduced), the fastest the branch and bound will be performed. Hence, it is
 * also recommended to perform a basis reduction before the figures of merit
 * computation to prevent an explosion of the computing time.
 * 
 * When doing the spectral test, the shortest vector given by the Branch and
 * Bound shall be compared to an upper bound on its length. *LatticeTester*
 * proposes several normalization based on the sphere packing problem given in
 * \cite mCON99a.
 * 
 * The vast majority - and more specifically LLL and BKZ reduction - of the
 * implementation is based on the NTL library developped by Victor Shoup
 * \cite iSHO05a. It is based itself on the GNU Multiple Precision Arithmetic
 * Library (GMP) \cite iGMP06a, which allow arbitrary precision for
 * calculations.
 * 
 * 
 * */
