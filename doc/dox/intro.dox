/**
 * \page intro Background and overview
 *
 *   LatMRG is a software system implemented as a library of classes written
 * in the C++ language. 
 *
 *   It provides different tools for studying the
 * structure of lattices in the real space and for examining the theoretical
 * properties of random number generators based on linear recurrences in
 * modular arithmetic or the properties of integration lattices (for now,
 * Korobov and rank 1 lattices). It offers facilities for checking if a
 * generator has maximal period or not, for examining its lattice structure
 * (e.g., applying lattice and spectral tests), and for performing computer
 * searches for "good" generators according to different quality criteria.
 * The software can also be used for related applications, such as searching
 * and evaluating lattice rules for quasi-Monte Carlo integration.
 *
 *   In this section, we give a quick recall of some definitions and
 * notation, as well as a short outline of what the package does. For more
 * details on the underlying theory and algorithms, see \cite rCOU96x,
 * \cite rLEC94e&thinsp; and other references given there. We classify the
 * modules of LatMRG in three groups: (a) low-level, (b) intermediate-level,
 * and (c) high-level. Higher-level programs import facilities from the
 * lower-level ones.
 *
 *   The high-level modules (c) are programs in executable form which read
 * their data from files. They can either analyze a given generator or seek
 * "good" generators according to different criteria. Examples of data files
 * and results are given in Section 2. Appendix A gives specifications of the
 * data file formats and of what the programs do.
 *
 *   The intermediate-level classes (b) provide data types and methods to
 * construct lattice bases for different classes of generators (simple or
 * combined MRGs, lacunary indices, etc.), manipulate such bases, find a
 * shortest vector in a lattice, reduce a basis in the sense of Minkowski,
 * and so on. These tools are used by the upper-level programs (c), but can
 * also be used directly to make programs different than those already
 * provided at level (c), offering thus more flexibility. The lower-level
 * classes (a) implement basic operations on scalars, vectors, matrices,
 * polynomials, and so on. They allow different possible representations for
 * these objects, depending, for example, on the size of the modulus \f$m\f$
 * and the precision we want, as explained in Section 1.6. These lower-level
 * tools are used by the modules of levels (b) and (c). The intermediate and
 * low-level classes are discussed a little further in Section 3, and their
 * specifications are given in appendices B and C.
 *
 *   # Lattices in the real space
 *
 *   The *lattices* considered here are discrete subspaces of the real space
 * \f$\mathbb R^t\f$, which can be expressed as
 * \anchor REF__sec1_eq_lattice
 *   \f[
 *     L_t = \left\{\mathbf{v}= \sum_{j=1}^t z_j\mathbf{v}_j\mid\mbox{ each } z_j\in\mathbb{Z}\right\}, \tag{lattice}
 *   \f]
 * where \f$t\f$ is a positive integer, and
 * \f$\mathbf{v}_1,…,\mathbf{v}_t\f$ are linearly independent vectors in
 * \f$\mathbb R^t\f$ which form a *basis* of the lattice. A
 * comprehensive treatment of such lattices can be found in
 * \cite mCON99a&thinsp;. The matrix \f$\mathbf{V}\f$, whose \f$i\f$th line
 * is \f$\mathbf{v}_i\f$, is the corresponding *generator matrix* of
 * \f$L_t\f$. A lattice \f$L_t\f$ shifted by a constant vector
 * \f$\mathbf{v}_0\not L_t\f$, i.e., a point set of the form \f$L’_t =
 * \{\mathbf{v}+\mathbf{v}_0 : \mathbf{v}\in L_t\}\f$, is called a *grid*, or
 * a *shifted lattice*. The lattices considered in this guide always contain,
 * or are contained in, the integer lattice \f$\mathbb{Z}^t\f$, i.e.,
 * \f$\mathbb{Z}^t\subseteq L_t\f$ or \f$L_t\subseteq\mathbb{Z}^t\f$.
 *
 *   The *dual lattice* of \f$L_t\f$ is defined as \f$L_t^* =
 * \{\mathbf{h}\in\mathbb R^t \mid\mathbf{h}\cdot\mathbf{v}\in\mathbb{Z}\f$ for
 * all \f$\mathbf{v}\in L_t\}\f$. The *dual* of a given basis
 * \f$\mathbf{v}_1,…,\mathbf{v}_t\f$ is the set of vectors
 * \f$\mathbf{w}_1,…,\mathbf{w}_t\f$ in \f$\mathbb R^t\f$ such that \f$\mathbf{v}_i\cdot\mathbf{w}_j =
 * \delta_{ij}\f$, where \f$\delta_{ij}=1\f$ if \f$i=j\f$, and
 * \f$\delta_{ij}=0\f$ otherwise. It forms a basis of the dual lattice.
 * These \f$\mathbf{w}_j\f$’s are the columns of the matrix
 * \f$\mathbf{V}^{-1}\f$, the inverse of the matrix \f$\mathbf{V}\f$. If
 * \f$m\f$ is any positive real number, a basis
 * \f$\{\mathbf{w}_1,…,\mathbf{w}_t\}\f$ satisfying
 * \f$\mathbf{v}’_i \mathbf{w}_j = \delta_{ij} m\f$ for all \f$i\f$, \f$j\f$
 * is called the \f$m\f$-dual of the basis
 * \f$\{\mathbf{v}_1,…,\mathbf{v}_t\}\f$. The lattice generated by this
 * \f$m\f$-dual basis is the \f$m\f$-dual to \f$L\f$. This extension of the
 * usual notion of dual basis and dual lattice will allow us, by a suitable
 * choice of \f$m\f$ [in our context it will be the modulus in {@link
 * REF__sec1_recurs (recurs)}], to deal uniquely with integer coordinate
 * vectors, which can be represented exactly on a computer.
 *
 *   The determinant of the matrix \f$\mathbf{V}\f$ is equal to the volume of
 * the fundamental parallelepiped
 * \f$\Lambda= \{\mathbf{v}= \lambda_1\mathbf{v}_1 +
 * \cdots+ \lambda_t\mathbf{v}_t \mid0\le\lambda_i\le1\f$ for
 * \f$1\le i\le t\}\f$, and is also the inverse of the average number of
 * points per unit of volume, independently of the choice of basis. It is
 * called the determinant of \f$L_t\f$. The quantity \f$1/\det(L_t) =
 * 1/\det(\mathbf{V}) = \det(\mathbf{V}^{-1})\f$ is called the *density* of
 * \f$L_t\f$. When \f$L_t\f$ contains \f$\mathbb{Z}^t\f$, the density is an
 * integer equal to the cardinality of the point set \f$L_t \cap[0,1)^t\f$.
 *
 *   For a given lattice \f$L_t\f$ and a subset of coordinates \f$I =
 * \{i_1,…,i_d\} \subseteq\{1,…,t\}\f$, denote by \f$L_t(I)\f$ the
 * projection of \f$L_t\f$ over the \f$d\f$-dimensional subspace determined
 * by the coordinates in \f$I\f$. This projection is also a lattice, whose
 * density divides that of \f$L_t\f$. There are exactly
 * \f$\det(L_t(I))/\det(L_t)\f$ points of \f$L_t\f$ that are projected onto
 * each point of \f$L_t(I)\f$. In group theory language, \f$L_t(I)\f$
 * corresponds to a coset of \f$L_t\f$.
 *
 *   # Multiple recursive generators
 *
 *   Consider the linear recurrence
 * \anchor REF__sec1_recurs
 *   \f[
 *     x_n = (a_1 x_{n-1} + \cdots+ a_k x_{n-k}) \mod m. \tag{recurs}
 *   \f]
 * where \f$m\f$ and \f$k\f$ are positive integers and each \f$a_i\f$ belongs
 * to the set (or ring) \f$\mathbb{Z}_m = \{0,1,…,m-1\}\f$. For
 * \f$n\ge0\f$, \f$s_n = (x_n,…,x_{n+k-1}) \in\mathbb{Z}_m^k\f$ is the
 * *state* at step \f$n\f$. The initial state \f$s_0\f$ is called the *seed*.
 * One can take \f$u_n = x_n/m \in[0,1)\f$ as the *output* at step \f$n\f$.
 * This kind of generator is called *multiple recursive* (MRG). When
 * \f$k=1\f$, it gives the well-known multiplicative linear congruential
 * generator (MLCG). MLCGs in *matrix form* can also be expressed as many
 * copies of the same MRG running in parallel. For more details, see
 * \cite rGRO88a, \cite rLEC90a, \cite rLEC94a, \cite rNIE86a&thinsp;.
 *
 *   The maximal possible period for the \f$s_n\f$’s is the cardinality of
 * \f$\mathbb{Z}_m^t\f$ minus 1, i.e. \f$\rho= m^k-1\f$. It is attained if
 * and only if \f$m\f$ is prime and the characteristic polynomial of {@link
 * REF__sec1_recurs (recurs)},
 * \anchor REF__sec1_charac
 *   \f[
 *     P(z) = \left(z^k - \sum_{i=1}^k a_i z^{k-i}\right) \mod m, \tag{charac}
 *   \f]
 * is a primitive polynomial modulo \f$m\f$. Knuth \cite rKNU97a&thinsp;
 * gives necessary and sufficient conditions for that, which are implemented
 * in our package. If \f$k=1\f$ and \f$m=p^e\f$, with \f$e > 1\f$, then the
 * maximal possible period is \f$2^{e-2}\f$ for \f$p=2\f$ and
 * \f$(p-1)p^{e-1}\f$ for \f$p > 2\f$ \cite rKNU97a, \cite rLEC90a&thinsp;.
 *
 *   Instead of taking \f$u_n = x_n/m\f$ for the output, one can take a more
 * general linear combination of the components of the state vector, say
 * \anchor REF__sec1_yn
 *   \anchor REF__sec1_output2
 *   \f{align}{
 *      y_n
 *      &
 *     =
 *      (b_1 x_n + \cdots+ b_k x_{n+k-1}) \mod m, \tag{yn}
 *    \\
 *     u_n
 *      &
 *     =
 *      y_n /m. \tag{output2}
 *   \f}
 * For any integer \f$t\ge1\f$, one has
 * \anchor REF__sec1_eq_tpoly
 *   \f[
 *   \begin{pmatrix}
 *      y_n
 *    \\
 *     y_{n+1}
 *    \\
 *   \vdots
 *    \\
 *     y_{n+t-1}
 *   \end{pmatrix} = \begin{pmatrix}
 *    \mathbf{b}’
 *    \\
 *   \mathbf{b}’\mathbf{A}
 *    \\
 *   \vdots
 *    \\
 *   \mathbf{b}’\mathbf{A}^{t-1}
 *   \end{pmatrix} \begin{pmatrix}
 *      x_n
 *    \\
 *     x_{n+1}
 *    \\
 *   \vdots
 *    \\
 *     x_{n+k-1}
 *   \end{pmatrix} \; \mod m =: \mathbf{B}_t \begin{pmatrix}
 *      x_n
 *    \\
 *     x_{n+1}
 *    \\
 *   \vdots
 *    \\
 *     x_{n+k-1}
 *   \end{pmatrix} \; \mod m, \tag{tpoly}
 *   \f]
 * where \f$\mathbf{b}’ = (b_1,…,b_k)\f$ and
 * \anchor REF__sec1_eq_companion
 *   \f[
 *     A = \begin{pmatrix}
 *      0
 *      &
 *     1
 *      &
 *     …
 *      &
 *     0
 *    \\
 *   \vdots
 *      &
 *   \vdots
 *      &
 *   \ddots
 *      &
 *   \vdots
 *    \\
 *     0
 *      &
 *     0
 *      &
 *     …
 *      &
 *     1
 *    \\
 *     a_k
 *      &
 *     a_{k-1}
 *      &
 *     …
 *      &
 *     a_1
 *   \end{pmatrix} \tag{companion}
 *   \f]
 * is the *companion matrix* of the characteristic polynomial \f$P(z)\f$. In
 * particular, by taking \f$t=k\f$, one sees that the vector
 * \f$(y_n,…,y_{n+k-1})\f$ takes all possible values in
 * \f$\mathbb{Z}_m^k\f$, when \f$(x_n,…,x_{n+k-1})\f$ does so, if and only if
 * the matrix \f$\mathbf{B}_k\f$ has full rank. The matrix
 * \f$\mathbf{B}_t\f$ can be constructed easily as follows. Put
 * \f$(x_n,…,x_{n+k-1})’ = \mathbf{e}_j\f$, the \f$j\f$th vector of the
 * canonical basis, with \f$x_{n+i-1} = \delta_{ij}\f$, and compute the
 * corresponding column vector \f$(y_n,…,y_{n+t-1})’\f$ via {@link
 * REF__sec1_recurs (recurs)} and {@link REF__sec1_yn (yn)}. This vector is
 * the \f$j\f$th column of the matrix \f$\mathbf{B}_t\f$.
 *
 *   # Lattice structure and spectral test
 *
 *   Let \f$\Psi_t\f$ be the multiset of all the \f$t\f$-dimensional vectors
 * of successive output values of an MRG, from all possible seeds in
 * \f$\mathbb{Z}_m^k\f$, i.e.,
 * \f[
 *   \Psi_t = \left\{\mathbf{u}_{0,t} = (x_0/m,…,x_{t-1}/m) \mid(x_0,…,x_{k-1})\in\mathbb{Z}_m^k\right\}.
 *   \f]
 * For \f$t\le k\f$, this set is just \f$\mathbb{Z}_m^t\f$ with each element
 * repeated \f$m^{k-t}\f$ times. For \f$t > k\f$, the first \f$k\f$
 * components of a vector \f$\mathbf{u}_{0,t}\in\Psi_t\f$ are arbitrary
 * elements of \f$\mathbb{Z}_m/m\f$, but once they are fixed, the remaining
 * \f$t-k\f$ components are determined uniquely by the linear recurrence
 * {@link REF__sec1_recurs (recurs)}. The last \f$t-k\f$ components are thus
 * linear combinations modulo \f$1\f$, with integer coefficients, of the
 * first \f$k\f$ components.
 *
 *   For \f$1\le i\le k\f$, let \f$\mathbf{v}_i = (v_{i,1},…,v_{i,t})\f$ be
 * the \f$t\f$-dimensional vector with components
 * \f$v_{i,j}=\delta_{ij}/m\f$ for \f$i\le k\f$, and \f$v_{i,j} = (a_1
 * v_{i,j-1} +\cdots+ a_k v_{i,j-k})\mod1\f$ for \f$j > k\f$. For
 * \f$k+1\le i\le t\f$, let \f$\mathbf{v}_i = \mathbf{e}_i\f$, the \f$i\f$th
 * unit vector in \f$t\f$ dimensions. These vectors are a basis of a lattice
 * \f$L_t\f$ that contains \f$\mathbb{Z}^t\f$, with unit cell volume of
 * \f$\max(m^{-t}, m^{-k})\f$, such that \f$L_t \cap[0,1)^t =
 * \Psi_t\f$. In fact, \f$L_t = \Psi_t + \mathbb{Z}^t =
 * \{\mathbf{v}= \tilde{\mathbf{v}}+ \mathbf{z}\mid\tilde{\mathbf{v}}\in\Psi_t\f$ and
 * \f$\mathbf{z}\in\mathbb{Z}^t\}\f$. The vectors \f$\mathbf{w}_i =
 * (w_{i,1},…,w_{i,t})\f$, \f$1\le i\le t\f$, where
 * \f[
 *     w_{i,j} = \begin{cases}
 *      m
 *      &
 *    \text{for $j=i\le k$};
 *    \\
 *     0
 *      &
 *    \text{for $j\not i\le k$;}
 *    \\
 *     v_{j,i}
 *      &
 *    \text{for $i > k\ge j$;}
 *    \\
 *     1
 *      &
 *    \text{for $j=i > k$;}
 *    \\
 *     0
 *      &
 *    \text{for $k < j\not i >k$,}
 *   \end{cases}
 *   \f]
 * are linearly independent and satisfy \f$\mathbf{v}_i\cdot\mathbf{w}_j =
 * \delta_{ij}\f$. They form the dual basis to
 * \f$\{\mathbf{v}_1,…,\mathbf{v}_t\}\f$. The vectors \f$\mathbf{v}_i\f$ and
 * \f$\mathbf{w}_j\f$ are the lines of the matrices:
 * \f[
 *   \mathbf{V}_t = (\mathbf{v}_1 \mathbf{v}_2 \cdots\mathbf{v}_t)’ = \begin{pmatrix}
 *      1/m
 *      &
 *     0
 *      &
 *     …
 *      &
 *     0
 *      &
 *      v_{1,k+1}
 *      &
 *      …
 *      &
 *      v_{1,t}
 *    \\
 *     0
 *      &
 *      1/m
 *      &
 *     …
 *      &
 *     0
 *      &
 *      v_{2,k+1}
 *      &
 *      …
 *      &
 *      v_{2,t}
 *    \\
 *   \vdots
 *      &
 *   \vdots
 *      &
 *   \ddots
 *      &
 *   \vdots
 *      &
 *   \vdots
 *      &  &
 *    \vdots
 *    \\
 *     0
 *      &
 *      0
 *      &
 *     …
 *      &
 *     1/m
 *      &
 *      v_{k,k+1}
 *      &
 *      …
 *      &
 *      v_{k,t}
 *    \\
 *     0
 *      &
 *      0
 *      &
 *     …
 *      &
 *      0
 *      &
 *      1
 *      &
 *      …
 *      &
 *      0
 *    \\
 *   \vdots
 *      &
 *   \vdots
 *      &
 *   \ddots
 *      &
 *   \vdots
 *      &
 *   \vdots
 *      &
 *    \ddots
 *      &
 *    \vdots
 *    \\
 *     0
 *      &
 *      0
 *      &
 *     …
 *      &
 *      0
 *      &
 *      0
 *      &
 *      …
 *      &
 *      1
 *   \end{pmatrix}
 *   \f]
 * and
 * \f[
 *   \mathbf{W}_t = (\mathbf{w}_1 \mathbf{w}_2 \cdots\mathbf{w}_t)’ = \begin{pmatrix}
 *      m
 *      &
 *      0
 *      &
 *     …
 *      &
 *     0
 *      &
 *      0
 *      &
 *      …
 *      &
 *      0
 *    \\
 *     0
 *      &
 *      m
 *      &
 *     …
 *      &
 *     0
 *      &
 *      0
 *      &
 *      …
 *      &
 *      0
 *    \\
 *   \vdots
 *      &
 *   \vdots
 *      &
 *   \ddots
 *      &
 *   \vdots
 *      &
 *   \vdots
 *      &  &
 *    \vdots
 *    \\
 *     0
 *      &
 *      0
 *      &
 *     …
 *      &
 *     m
 *      &
 *      0
 *      &
 *      …
 *      &
 *      0
 *    \\
 *     -v_{1,k+1}
 *      &
 *      -v_{2,k+1}
 *      &
 *     …
 *      &
 *      -v_{k,k+1}
 *      &
 *      1
 *      &
 *      …
 *      &
 *      0
 *    \\
 *   \vdots
 *      &
 *   \vdots
 *      &
 *   \ddots
 *      &
 *   \vdots
 *      &
 *   \vdots
 *      &
 *    \ddots
 *      &
 *    \vdots
 *    \\
 *     -v_{1,t}
 *      &
 *      -v_{2,t}
 *      &
 *     …
 *      &
 *      -v_{k,t}
 *      &
 *      0
 *      &
 *      …
 *      &
 *      1
 *   \end{pmatrix},
 *   \f]
 * and one has \f$\mathbf{W}’_t \mathbf{V}_t = I\f$. In the package LatMRG,
 * we store the vectors \f$m\mathbf{v}_i\f$ instead of \f$\mathbf{v}_i\f$ in
 * the computer, for the components of the former vectors are integer-valued
 * and can thus be represented exactly in the computer.
 *
 *   For the more general case of {@link REF__sec1_yn (yn)} and {@link
 * REF__sec1_output2 (output2)}, replace the first \f$k\f$ lines of
 * \f$\mathbf{V}_t\f$ by \f$\mathbf{B}’_t\f$. If \f$\mathbf{B}_k\f$ is
 * invertible, then \f$\mathbf{B}_t\f$ has rank \f$k\f$ and the lines
 * \f$k+1\f$ to \f$t\f$ of \f$\mathbf{V}\f$ complete the lattice basis as
 * before. Otherwise, remove the lines in \f$\mathbf{B}’_t\f$ which are
 * linearly dependent of others, to obtain a matrix of full rank \f$k’<k\f$,
 * and replace them by \f$k-k’\f$ vectors of the canonical basis of
 * \f$\mathbb R^t\f$, divided by \f$m\f$, chosen in a way that the
 * first \f$k\f$ lines and \f$k\f$ columns of \f$\mathbf{V}_t\f$ form an
 * invertible matrix. In both cases, the dual basis is obtained by inverting
 * the matrix \f$\mathbf{V}’_t\f$. For LCGs in matrix form, bases for
 * \f$L_t\f$ and its dual can be constructed as explained in \cite rGRO88a,
 * \cite rLEC94e&thinsp;.
 *
 *   If one adds a constant \f$b\f$ on the right-hand-side of {@link
 * REF__sec1_recurs (recurs)}, before applying the modulo operation, then the
 * vectors of successive values will all belong to \f$L’_t\f$, where \f$L’_t
 * = L_t + \mathbf{v}_{0,t}\f$ is a shift of \f$L_t\f$ by some constant
 * \f$v_{0,t}\in\mathbb{Z}_m^t\f$, i.e., a *grid*. Since \f$L’_t\f$ and
 * \f$L_t\f$ have the same structural properties, we simply ignore the
 * presence of such a constant \f$b\f$ in LatMRG, and consider only
 * homogeneous recurrences.
 *
 *   When \f$m\f$ is prime and the MRG has full period \f$m^k-1\f$, then
 * \f$\Psi_t\f$ is the set of all \f$t\f$-tuples produced by the generator
 * over its main cycle, plus the **0** vector. Otherwise, the set of
 * \f$t\f$-dimensional vectors produced over any given (sub)cycle (plus the
 * **0** vector and plus \f$m\mathbb{Z}^t\f$) is a strict subset of \f$L_t\f$
 * which in general does not form a lattice. Then, LatMRG can analyze the set
 * of all \f$t\f$-tuples produced over the *union* of all subcycles. In some
 * cases, however, the vectors of successive values over one subcycle
 * generate a strict sublattice of \f$L_t\f$, whose intersection with
 * \f$[0,1)^t\f$ contains only a fraction of the points of
 * \f$\Psi_t\f$. This is what happens in particular when \f$k=1\f$, \f$m\f$
 * is a power of a prime \f$p\f$, and \f$x_0\f$ is prime to \f$p\f$. The
 * package can take care of the latter case by constructing a basis for the
 * appropriate sublattice.
 *
 *   # Lacunary indices
 *
 *   Instead of forming vectors with successive values like in the above
 * definition of \f$\Psi_t\f$, one can form vectors with values that are
 * some distance apart in the sequence (so-called "leapfrog" values).
 * \anchor REF__sec1_sec_lacunary Let \f$I=\{i_1 , i_2 , \cdots, i_t\}\f$ be
 * a set of fixed integers. Define
 * \anchor REF__sec1_psi2
 *   \f[
 *   \psi_t(I) = \left\{(u_{i_1},…,u_{i_t}) \mid(x_0,…,x_{k-1}) \in\mathbb{Z}_m^k\right\} \tag{psi2}
 *   \f]
 * and let \f$L_t(I) = \psi_t(I) + \mathbb{Z}^t\f$. If we assume that
 * \f$0\le i_1 < i_2 < \cdots< i_t\f$, this \f$L_t(I)\f$ is the projection
 * of the lattice \f$L_{i_t+1}\f$ over the \f$t\f$-dimensional subspace
 * determined by the coordinates that belong to \f$I\f$. Using the class
 * <tt>IntLattice</tt>, one can build a basis for \f$L_t\f$ and its dual in
 * this more general case, and then perform lattice analysis as usual.
 * Further details and examples are given in \cite rLEC97c&thinsp;. For
 * \f$(i_1,…,i_t) = (0,…,t-1)\f$, one has \f$L_t(I) = L_t\f$.
 *
 *   To construct the basis in this case, one must compute the vector
 * \f$(u_{i_1},…,u_{i_t})\f$ obtained when the seed
 * \f$(x_0,…,x_{k-1})=\mathbf{e}_i\f$, for each vector \f$\mathbf{e}_i\f$ of
 * the canonical basis. The linear transformation from the state
 * \f$(x_0,…,x_{k-1})\f$ to the vector \f$(u_{i_1},…,u_{i_t})\f$ is
 * one-to-one for each \f$t\ge k\f$ if and only if the transformation applied
 * to the \f$k\f$ vectors of the canonical basis gives \f$k\f$ linearly
 * independent vectors for \f$t=k\f$. For \f$t < k\f$, the transformation is
 * onto (surjective) if and only if the transformation gives \f$t\f$ linearly
 * independent vectors, that is, if the corresponding matrix has full rank
 * \f$t\f$.
 *
 *   # Figures of Merit
 *
 *   Figures of merit measure the quality of lattices. Here, good quality
 * means that the points cover the space very evenly, i.e., are very
 * uniformly distributed. There are many ways of measuring this uniformity,
 * which give rise to several different figures of merit.
 * \anchor REF__sec1_sec_merit
 *
 *   ## The spectral test
 *
 *   The lattice structure also means that all points of \f$L_t\f$ lie in a
 * family of equidistant parallel hyperplanes. Among all such families of
 * hyperplanes that cover all the points, choose the one for which the
 * successive hyperplanes are farthest apart. The distance between these
 * successive hyperplanes is in fact equal to \f$1/\ell_t\f$ where
 * \f$\ell_t\f$ is the Euclidean length of the shortest nonzero vector in
 * the *dual* lattice \f$L_t^*\f$. So for a given density of points, we want
 * \f$\ell_t\f$ to be as large as possible. Computing this \f$\ell_t\f$ for
 * an MRG and comparing with the best possible value, given \f$t\f$, \f$m\f$,
 * and \f$k\f$, is known as the *spectral test* in the literature on RNGs
 * \cite rKNU97a, \cite sFIS96a&thinsp;.
 *
 *   We can view the lattice as a way of packing the space by spheres of
 * radius \f$\ell_t/2\f$, with one sphere centered at each lattice point. In
 * the dual lattice, this gives \f$1/n = m^{-k}\f$ spheres per unit volume.
 * If we rescale so that the radius of each sphere is 1, we obtain
 * \f$\delta_t = (\ell_t/2)^t/n\f$ spheres per unit volume. This number
 * \f$\delta_t\f$ is called the *center density* of the lattice. For a given
 * value of \f$n\f$, an upper bound on \f$\ell_t\f$ can be obtained in terms
 * of an upper bound on \f$\delta_t\f$ [one has \f$\ell_t = 2
 * (n\delta_t)^{1/t}\f$], and vice-versa. Let \f$\delta_t^*\f$ be the
 * largest possible value of \f$\delta_t\f$ for a lattice (i.e., the densest
 * packing by non-overlapping spheres arranged in a lattice). The quantity
 * \f$\gamma_t = 2(\delta_t^*)^{2/t}\f$ is called the *Hermite constant*
 * for dimension \f$t\f$ \cite mCON99a, \cite mGRU87a&thinsp;. It gives the
 * upper bound \f$\ell_t^2\le(\ell_t^*(n))^2 = 2(n\delta_t^*)^{2/t} =
 * \gamma_t n^{2/t}\f$ for a lattice of density \f$1/n\f$. Knowing the
 * Hermite constants, or good approximations of them, is useful because it
 * allows us to normalize \f$\ell_t\f$ to a value between 0 and 1 by taking
 * \f$\ell_t/\ell_t^*(m^k)\f$. This is convenient for comparing values for
 * different values of \f$t\f$ and \f$m^k\f$. Good values are close to 1 and
 * bad values are close to 0.
 *
 *   The Hermite constants are known exactly only for \f$t\le8\f$, in which
 * case the densest lattice packings are attained by the *laminated* lattices
 * \cite mCON99a&thinsp;. Conway and Sloane \cite mCON99a&thinsp; (Table 1.2)
 * give the values of \f$\delta_t^*\f$ for \f$t\le8\f$, and provide lower
 * and upper bounds on \f$\delta_t^*\f$ for other values of \f$t\f$. The
 * largest value of \f$\ell_t^2/n^{2/t}\f$ obtained so far for concrete
 * lattice constructions is a lower bound on \f$\gamma_t\f$, which we denote
 * by \f$\gamma_t^{\mathrm{B}}\f$. Such values are given in Table 1.2 of
 * \cite mCON99a&thinsp;, page 15, in terms of \f$\delta^*\f$. The laminated
 * lattices, which give the lower bound
 * \f$\ell_t^2/n^{2/t} \ge\gamma_t^{\mathrm{L}} = 4
 * \lambda_t^{-1/t}\f$, where the constants \f$\lambda_t\f$ are given in
 * \cite mCON88a&thinsp; (Table 6.1, page 158) for \f$t\le48\f$, are the
 * best constructions in dimensions 1 to 29, except for dimensions 10 to 13.
 * (One has \f$\gamma_t^{\mathrm{L}} = \gamma_t\f$ for \f$t\le8\f$.)
 *
 *   Minkowski proved that there exists lattices with density satisfying
 * \f$\delta_t \ge\zeta(t) / (2^{t-1} V_t)\f$ where \f$\zeta(t) =
 * \sum_{k=1}^{\infty}k^{-t}\f$ is the Riemann zeta function and \f$V_t =
 * \pi^{t/2} / (t/2)!\f$ is the volume of a \f$t\f$-dimensional sphere of
 * radius 1. This bound provides a lower bound \f$\gamma_t^Z\f$ on
 * \f$\gamma_t\f$.
 *
 *   An upper bound on \f$\gamma_t\f$ is obtained via the bound of Rogers on
 * the density of sphere packings \cite mCON99a&thinsp;. This upper bound can
 * be written as
 * \f[
 *   \gamma_t^{\mathrm{R}} = 4* 2^{2R(t)/t}
 *   \f]
 * where \f$R(t)\f$ can be found in Table&nbsp;1.2 of \cite mCON99a&thinsp;
 * for \f$t\le24\f$, and can be approximated with \f$O(1/t)\f$ error and
 * approximately 4 decimal digits of precision, for \f$t\ge25\f$, by
 * \f[
 *     R(t) = \frac{t}{2} \log_2\left(\frac{t}{4\pi e}\right) + \frac{3}{2} \log_2 (t) - \log_2 \left(\frac{e}{\sqrt{\pi}}\right) + \frac{5.25}{t + 2.5}.
 *   \f]
 * Table&nbsp;1 in \cite rLEC99c&thinsp; gives the ratio
 * \f$(\gamma_t^{\mathrm{L}} / \gamma_t^{\mathrm{R}})^{1/2}\f$, of the
 * lower bound over the upper bound on \f$\ell_t\f$, for
 * \f$1\le t\le48\f$. This ratio tends to decrease with \f$t\f$, but not
 * monotonously.
 *
 *   Computing the shortest vector in terms of the Euclidean norm is
 * convenient, e.g., for computational reasons, but one can also use another
 * norm instead. For example, one can take the
 * \f$\mathcal{L}_p\f$-norm, defined by \f$\Vert\mathbf{v}\Vert_p =
 * (|v_1|^p + \cdots+ |v_t|^p)^{1/p}\f$ for \f$1\le p < \infty\f$ and
 * \f$\Vert\mathbf{v}\Vert_{\infty}= \max(|v_1|, …, |v_t|)\f$ for \f$p =
 * \infty\f$. The inverse of the length of the shortest vector is then the
 * \f$\mathcal{L}_p\f$-distance between the successive hyperplanes for the
 * family of hyperplanes that are farthest apart among those that cover
 * \f$L_t\f$. For \f$p=1\f$, the length \f$\ell_t =
 * \Vert\mathbf{v}\Vert_1\f$ of the shortest vector \f$\mathbf{v}\f$ (or
 * \f$\Vert\mathbf{h}\Vert_1 - 1\f$ in some cases, see
 * \cite rKNU97a&thinsp;) is the minimal number of hyperplanes that cover all
 * the points of \f$\Psi_t\f$. The following upper bound on \f$\ell_t\f$ in
 * this case was established by Marsaglia \cite rMAR68a&thinsp; by applying
 * the general convex body theorem of Minkowski:
 * \f[
 *   \ell_t \le\ell_t^*(m^k) = (t! m^k)^{1/t} =: \gamma_t^M m^{k/t}.
 *   \f]
 * This upper bound can be used to normalize \f$\ell_t\f$ in this case.
 *
 *   — Upper bound on \f$\ell_t\f$ in general: Minkowski. ?
 *
 *   As a figure of merit, we take the worst-case value of
 * \f$\ell_t/\ell_t^*(m^k)\f$ over certain values of \f$t\f$ and for
 * selected projections on lower-dimensional subspaces. More specifically,
 * let \f$\ell_I\f$ denote the length of the shortest nonzero vector
 * \f$\mathbf{v}\f$ in \f$L_t^*(I)\f$, and \f$\ell_t =
 * \ell_{\{1,…,t\}}\f$ as before. For arbitrary positive integers
 * \f$t_1\ge\cdots\ge t_d \ge d\f$, consider the worst-case figure of merit
 * \anchor REF__sec1_eq_M
 *   \f[
 *     M_{t_1,…,t_d} = \min\left[ \min_{k+1\le t\le t_1} \ell_t/\ell_t^*(m^k),\min_{2\le s\le k} \min_{I\in S(s,t_s)} \ell_I/m, \min_{k+1\le s\le d} \min_{I\in S(s,t_s)} \ell_I/\ell_s^*(m^k) \right], \tag{M}
 *   \f]
 * where \f$S(s,t_s) = \{I=\{i_1,…,i_s\} \mid1 = i_1 <
 * \cdots< i_s\le t_s\}\f$. This figure of merit makes sure that the lattice
 * is good in projections over \f$t\f$ successive dimensions for all
 * \f$t\le t_1\f$, and over non-successive dimensions that are not too far
 * apart. Note that when \f$s\le k\f$, the smallest distance between
 * hyperplanes that can be achieved in \f$s\f$ dimensions for the MRG is
 * \f$1/m\f$, so \f$\ell_s/m\f$ cannot exceed 1, and it is equal to 1 if and
 * only if the linear transformation from the state \f$(x_0,…,x_{k-1})\f$ to
 * the output vector \f$(u_{i_1},…,u_{i_s})\f$ is surjective (i.e., the
 * corresponding matrix has full rank). For \f$s<k\f$, \f$m\f$ is typically
 * much smaller than \f$\ell_s^*(m^k)\f$, and this is the reason for
 * separating the last two terms in {@link REF__sec1_eq_M (M)}.
 *
 *   The figure of merit \f$M_{t_1} =
 * \min_{2\le s\le t_1} \ell_s/\ell_s^*(n)\f$ (with \f$d=1\f$) has been
 * widely used for ranking and selecting LCGs and MRGs \cite sFIS96a,
 * \cite rLEC99b, \cite rLEC99c&thinsp;. The quantity \f$M_{t_1,…,t_d}\f$ is
 * a worst case over \f$(t_1-d) +
 * \sum_{s=2}^d \binom{t_s-1}{s-1}\f$ projections, and this number increases
 * quickly with \f$d\f$ unless the \f$t_s\f$ are very small. For example, if
 * \f$d=4\f$ and \f$t_s = t\f$ for each \f$s\f$, there are 5019 projections
 * for \f$t = 32\f$. When too many projections are considered, there are
 * inevitably some that are bad, so the worst-case figure of merit is
 * (practically) always small, and can no longer distinguish between good and
 * mediocre behavior in the most important projections. Moreover, the time to
 * compute \f$M_{t_1,…,t_d}\f$ increases with the number of projections. We
 * should therefore consider only the projections deemed important. We
 * suggest using the criterion {@link REF__sec1_eq_M (M)} with \f$d\f$ equal
 * to 4 or 5, and \f$t_s\f$ decreasing with \f$s\f$.
 *
 *   Instead of considering the shortest nonzero vector in the dual lattice,
 * one can consider the shortest nonzero vector in the primal lattice
 * \f$L_t\f$. Its length represents the distance to the nearest other lattice
 * point from any point of the lattice. A small value means that many points
 * are placed on the same line, at some fixed distance apart.
 *
 *   ## Minkowski reduced basis
 *
 *   Another way of measuring the quality of a lattice is in terms of the
 * relative lengths of the smallest and largest vectors in a *reduced* basis.
 * A basis can be *reduced* in different senses. One type of reduced basis
 * considered by this package is a *Minkowski-reduced lattice basis* (MRLB)
 * (see \cite rAFF85a, \cite rAFF88a, \cite rGRO88a&thinsp; for more
 * details). Roughly, a MRLB is a basis for which the vectors are in some
 * sense the most orthogonal. The ratio of the sizes of the shortest and
 * longest vectors of a MRLB is called its *Beyer-quotient*. In general, a
 * given lattice may have several MRLBs, all with the same length of the
 * shortest vector, but perhaps with different lengths of the longest vector,
 * and thus different Beyer quotients. We define \f$q_t(I)\f$ as the maximum
 * of the Beyer quotients of all MRLBs of \f$L_t(I)\f$, and denote
 * \f$q_t(\{1,…,t\})\f$ by \f$q_t\f$. We prefer values of \f$q_t(I)\f$ close
 * to 1. Similar to {@link REF__sec1_eq_M (M)}, we define
 * \anchor REF__sec1_eq_Q
 *   \f[
 *     Q_{t_1,…,t_d} = \min\left[ \min_{k+1\le t\le t_1} q_t,\min_{2\le s\le d} \min_{I\in S(s,t_s)} q_t(I) \right]. \tag{Q}
 *   \f]
 * Computing \f$q_t\f$ is much more time consuming than computing the
 * spectral test.
 *
 *   ## The P<sub>\f$\alpha\f$</sub> criterion
 *
 *    \anchor REF__sec1_sec_palpha
 *
 *   The quantity \f$\mathcal{P}_{\alpha}\f$ is a measure of non-uniformity
 * (i.e., discrepancy from the uniform distribution, the smaller the better),
 * which has been widely used in the context of quasi-Monte Carlo integration
 * (see, e.g., \cite vSLO94a&thinsp;). In the case where \f$\Psi_t = L_t
 * \cap[0,1)^t\f$ where \f$L_t\f$ is a lattice with dual \f$L_t^*\f$, one
 * has
 * \anchor REF__sec1_eq_palpha
 *   \f[
 *   \mathcal{P}_{\alpha}(\Psi_t) = \sum_{\boldsymbol{0}\not\mathbf{w}\in L_t^*} \|\mathbf{w}\|_{\pi}^{-\alpha}, \tag{palpha}
 *   \f]
 * where \f$\|\mathbf{w}\|_{\pi}=\prod_{j=1}^t \max(1,|w_j|)\f$ for
 * \f$\mathbf{w}= (w_1,…,w_t)\f$. For any positive integer
 * \f$\alpha\f$, \f$\mathcal{P}_{2\alpha}(\Psi)\f$ can be written
 * equivalently as
 * \anchor REF__sec1_eq_palpha2
 *   \f{align}{
 *    \mathcal{P}_{2\alpha}(\Psi_t) = -1 + \frac{1}{n}\sum_{\mathbf{u}\in\Psi_t} \prod_{j=1}^t \left[1 - \frac{(-4\pi^2)^{\alpha}}{(2\alpha) !} B_{2\alpha}(u_j)\right] \tag{palpha2}
 *   \f}
 * where the \f$B_{\alpha}\f$ are the Bernoulli polynomials:
 * \f{align*}{
 *      B_0(x)
 *      &
 *     =
 *      1,
 *    \\
 *     B_1(x)
 *      &
 *     =
 *      x -1/2,
 *    \\
 *     B_2(x)
 *      &
 *     =
 *      x^2 - x + 1/6,
 *    \\
 *     B_3(x)
 *      &
 *     =
 *      x^3 - 3x^2/2 + x/2,
 *    \\
 *     B_4(x)
 *      &
 *     =
 *      x^4 - 2x^3 + x^2 - 1/30,
 *   \f}
 * and the other polynomials can be found via the identity
 * \f[
 *   \frac{t e^{xt}}{e^t-1} = \sum_{i=0}^{\infty}\frac{ B_i(x) t^i}{i!}.
 *   \f]
 * Hickernell \cite vHIC98c&thinsp; introduced generalizations of
 * \f$\mathcal{P}_{\alpha}\f$, incorporating weights and replacing the
 * simple sum in {@link REF__sec1_eq_palpha (palpha)} by a more general norm.
 * One version of this weighted \f$\mathcal{P}_{\alpha}\f$, where the weight
 * associated to the projection over the coordinates in a set \f$I\f$ has the
 * *product-form* \f$\beta_I = \beta_0\prod_{j\in I}\beta_j\f$, can be
 * defined by
 * \anchor REF__sec1_eq_palpha3
 *   \f{align}{
 *    \mathcal{P}_{2\alpha} (\Psi_t) = -\beta_0 + \frac{\beta_0}{n} \sum_{\mathbf{u}\in\Psi_t} \prod_{j=1}^t \left[1 - \frac{(-4\pi^2\beta_j^2)^{\alpha}}{(2\alpha)!} B_{2\alpha}(u_j)\right] \tag{palpha3}
 *   \f}
 * when \f$\alpha\f$ is an integer. The identity {@link REF__sec1_eq_palpha2
 * (palpha2)} or {@link REF__sec1_eq_palpha3 (palpha3)} gives an algorithm
 * for computing \f$\mathcal{P}_{2\alpha}(\Psi_t)\f$ in time \f$O(nt)\f$
 * when \f$\alpha\f$ is an integer and \f$\Psi_t\f$ is the intersection of
 * a lattice with \f$[0,1)^t\f$. Note that the
 * \f$D_{\mathcal{F},\alpha,p}(P)\f$ of \cite vHIC00b&thinsp; corresponds to
 * \f$(\mathcal{P}_{2\alpha}(\Psi_t))^{1/2}\f$ for
 * \f$\Psi_t=P\f$, \f$p=2\f$, and \f$\beta_j=1\f$ for all \f$j\f$. LatMRG
 * provides tools for computing \f$\mathcal{P}_{\alpha}\f$ with or without
 * weights.
 *
 *   It has been proved (e.g., \cite vSLO94a&thinsp;, Theorem 4.4, page 83)
 * that for any \f$t\ge2\f$, \f$\alpha> 1\f$, and prime number \f$m >
 * e^{\alpha t/(\alpha-1)}\f$, there exists at least one LCG with modulus
 * \f$m\f$ such that
 * \f[
 *   \mathcal{P}_{\alpha}(\Psi_t) \le\frac{[(e/t)(2\ln m + t)]^{\alpha t}}{ m^{\alpha}}.
 *   \f]
 * The latter quantity can then be used to normalize
 * \f$\mathcal{P}_{\alpha}\f$.
 *
 *   Alternatively, Hickernell et al. \cite vHIC01a&thinsp;, section 4.1,
 * suggest using the figure of merit \f$g_t\f$, where
 * \anchor REF__sec1_eq_palpha4
 *   \f{align}{
 *      g_t^2
 *      &
 *     =
 *    \frac{n^2}{(3/2)^t-1} \left(\frac{t-1}{t-1+\log n}\right)^{t-1} \mathcal{P}_2(\Psi_t) \nonumber
 *    \\  &
 *     =
 *    \frac{n}{ (3/2)^t-1} \left(\frac{t-1}{t-1+\log n}\right)^{t-1} \left[-n + \sum_{\mathbf{u}\in\Psi_t} \prod_{j=1}^t (1 + 3 B_{2\alpha}(u_j))\right] \tag{palpha4}
 *   \f}
 * is a normalized version of the inverse of {@link REF__sec1_eq_palpha3
 * (palpha3)} with \f$\alpha=1\f$, \f$\beta_0=1\f$, and \f$\beta_j =
 * \pi\sqrt{3/2}\f$ for \f$j\ge1\f$. This \f$g_t^2\f$ can be rewritten as
 * \anchor REF__sec1_eq_palpha5
 *   \f{align}{
 *      g_t^2
 *      &
 *     =
 *    \gamma_t^{\mathrm{P}}(n) \left[-n + \sum_{\mathbf{u}\in\Psi_t} \prod_{j=1}^t (1 + 3 B_{2\alpha}(u_j))\right] \tag{palpha5}
 *   \f}
 * where
 * \f[
 *   \gamma_t^{\mathrm{P}}(n) = \frac{n}{ (3/2)^t-1} \left(\frac{t-1}{t-1+\log n}\right)^{t-1}
 *   \f]
 * is a constant that depends on \f$t\f$ and \f$n\f$. As a figure of merit
 * based on \f$\mathcal{P}_2\f$, similar to {@link REF__sec1_eq_M (M)}, we
 * define
 * \anchor REF__sec1_eq_G
 *   \f[
 *     G_{t_1,…,t_d} = \min\left[ \min_{k+1\le t\le t_1} 1/g_t(\Psi_t), \min_{k+1\le s\le d} \min_{I\in S(s,t_s)} 1/g_t(\Psi_t(I)) \right]. \tag{G}
 *   \f]
 * # Matrix multiple recursive generators
 *
 *   MRGs in matrix form, which we denote MMRGs, have been introduced and
 * studied by Niederreiter \cite rNIE95b, \cite rNIE95c&thinsp;. The general
 * recurrence has the form
 * \anchor REF__sec1_MMRG
 *   \f[
 *   \mathbf{x}_n = (A_1 \mathbf{x}_{n-1} + \cdots+ A_k \mathbf{x}_{n-k}) \mod m \tag{MMRG}
 *   \f]
 * where \f$k\f$ and \f$m\f$ are the order and the modulus as for the MRG,
 * \f$\mathbf{x}_n = (x_{n,1},…,x_{n,w})’\f$ is a \f$w\f$-dimensional vector,
 * and each \f$A_j\f$ is a \f$w\times w\f$ square matrix, for some positive
 * integer \f$w\f$. The case \f$w=1\f$ corresponds to the usual MRG. The
 * recurrence {@link REF__sec1_MMRG (MMRG)} has full period \f$m^{kw}-1\f$ if
 * and only if \f$m\f$ is prime and the characteristic polynomial
 * \f[
 *     f(x) = \det\left( x^k I - x^{k-1} A_1 - x^{k-2} A_2 - \cdots- A_k\right)
 *   \f]
 * is a primitive polynomial modulo \f$m\f$ \cite rNIE95b&thinsp;.
 *
 *   There are different ways of producing the output. We consider the
 * following 3 cases:
 * \anchor REF__sec1_MMRG_out1
 *   \anchor REF__sec1_MMRG_out2
 *   \anchor REF__sec1_MMRG_out3
 *   \f{align}{
 *      u_{nw+i}
 *      &
 *     =
 *      x_{n,i} / m \qquad\mbox{ for $0\le i<w$ and $n\ge0$}, \tag{out1}
 *    \\
 *     u_n
 *      &
 *     =
 *    \frac{1}{ m} \left(\sum_{i=1}^w b_i x_{n,i} \mod m\right) = \sum_{i=1}^w b_i x_{n,i} / m \mod1 \qquad\mbox{ for $n\ge0$}, \tag{out2}
 *    \\
 *     u_n
 *      &
 *     =
 *    \sum_{i=1}^w x_{n,i} m^{-i} \qquad\mbox{ for $n\ge0$}, \tag{out3}
 *   \f}
 * where \f$b_1,…,b_w\f$ are positive integers. Case 3 is that used in
 * \cite rNIE95b&thinsp; and does not give rise to a lattice structure for
 * \f$\Psi_t\f$ in the usual sense. For both cases 1 and 2, the set
 * \f$\Psi_t\f$ is the intersection of a lattice \f$L_t\f$ with the unit
 * hypercube. Case 1 is used in \cite rNIE95c&thinsp;, where pseudorandom
 * numbers are generated in vector form, \f$w\f$ at a time. It is also
 * explained in \cite rNIE95c&thinsp; how to construct a basis for the
 * lattice \f$L_t\f$ when \f$t\f$ is a multiple of \f$w\f$. (The
 * generalization to other values of \f$t\f$ is trivial.)
 *
 *   — Give equivalence with MRG.
 *
 *   # Multiply-with-carry
 *
 *   A *Multiply-with-Carry* (MWC) generator \cite rCOU95a, \cite rCOU97a,
 * \cite rKOC95a, \cite rMAR94a&thinsp; is based on the recurrence
 * \anchor REF__sec1_mwc1
 *   \anchor REF__sec1_mwc2
 *   \f{align}{
 *      x_n
 *      &
 *     =
 *      (a_1 x_{n-1} + \cdots+ a_k x_{n-k} + c_{n-1}) \mod b, \tag{mwc1}
 *    \\
 *     c_n
 *      &
 *     =
 *      (a_1 x_{n-1} + \cdots+ a_k x_{n-k} + c_{n-1}) \div b, \tag{mwc2}
 *    \\
 *     u_n
 *      &
 *     =
 *      x_n / b. \nonumber
 *   \f}
 * where "div" denotes the integer division. The recurrence looks like that
 * of an MRG, except that a *carry* \f$c_n\f$ is propagated between the
 * steps.
 *
 *   Assume that \f$b\f$ is a power of 2, define \f$a_0 = -1\f$,
 * \f[
 *     m = \sum_{\ell=0}^k a_{\ell}b^{\ell},
 *   \f]
 * and let \f$a\f$ be the inverse of \f$b\f$ in arithmetic modulo \f$m\f$.
 * For simplicity, assume \f$m > 0\f$. Then, up to precision \f$1/b\f$, the
 * MWC generator is equivalent to the LCG:
 * \anchor REF__sec1_lcgz
 *   \f[
 *     z_n = a z_{n-1} \mod m; \qquad w_n = z_n/m. \tag{lcgz}
 *   \f]
 * In other words, if
 * \anchor REF__sec1_wdigit
 *   \f[
 *     w_n = \sum_{i=1}^{\infty}x_{n+i-1} b^{-i} \tag{wdigit}
 *   \f]
 * holds for \f$n=0\f$, then it holds for all \f$n\f$, and consequently
 * \f$|u_n - w_n| \le1/b\f$ for all \f$n\f$. The (approximate) lattice
 * structure of the MWC can therefore be analyzed by analyzing that of the
 * corresponding LCG {@link REF__sec1_lcgz (lcgz)}. This is what the LatMRG
 * package does.
 *
 *   If \f$a_{\ell}\ge0\f$ for \f$\ell\ge1\f$, then all the recurrent
 * states of the MWC satisfy \f$0\le c_n < a_1 + \cdots+ a_k\f$. In view of
 * this inequality, we want the \f$a_{\ell}\f$ to be small, so that their
 * sum fits into a computer word (e.g., \f$a_1 + \cdots+ a_k \le b\f$). But
 * the coefficients should not be too small either, because in dimension \f$t
 * = k+1\f$, one has (see \cite rCOU97a&thinsp;):
 * \anchor REF__sec1_dtkp1
 *   \f[
 *   \ell_t = (1 + a_1^2 + \cdots+ a_k^2)^{1/2}. \tag{dtkp1}
 *   \f]
 * Since \f$b\f$ is a power of 2, \f$a\f$ is a quadratic residue and so
 * cannot be primitive mod \f$m\f$. Therefore the period length cannot reach
 * \f$m-1\f$ even if \f$m\f$ is prime. But if \f$(m-1)/2\f$ is odd and 2 is
 * primitive mod \f$m\f$ (e.g., if \f$(m-1)/2\f$ is prime), then {@link
 * REF__sec1_lcgz (lcgz)} has period length \f$\rho= (m-1)/2\f$.
 *
 *   # Combined generators
 *
 *   Combining LCGs or MRGs with relatively prime moduli provides a efficient
 * way of implementing linear recurrences based on larger (non-prime) moduli.
 * The combination method that we consider adds, modulo \f$1\f$, the outputs
 * of the components. The package LatMRG permits one to specify a *product*
 * MRG in terms of its component MRGs with relatively prime moduli (see class
 * `MRGLatticeFactory)`. Its modulus is the product of the component moduli
 * and its order is the maximum of the orders of the components. The
 * recurrence governing this product MRG, when taken modulo any one of the
 * component moduli, reduces to the component recurrence. The combined
 * generator can then be studied via this product generator, since one can
 * view the former as embedded in the latter, and since both have the same
 * set of recurrent states (see \cite rCOU96a&thinsp;). Facilities are
 * provided to analyze, for any given MRG, either the lattice \f$L_t\f$
 * generated by all possible initial states, or that generated by the set of
 * recurrent states (see <tt>LatticeType</tt> in module <tt>Const</tt> and in
 * programs <tt>seek*</tt>).
 *
 *   Other types of combinations that have been proposed in the literature
 * are (often, depending on the parameters) closely approximated by
 * combinations of the above types \cite rLEC91b, \cite rLEC96b&thinsp;. They
 * can thus be analyzed with the present software.
 *
 *   # Computing a shortest nonzero vector or a reduced basis
 *
 *   The class <tt>Reducer</tt> computes a shortest nonzero vector in a
 * lattice via the branch-and-bound (BB) algorithm proposed by
 * \cite mFIN85a&thinsp;, with some additional refinements. For large
 * dimensions \f$t\f$, this algorithm is much faster than the algorithm given
 * in \cite rDIE75a, \cite rKNU81a&thinsp;. The class also computes a
 * Minkowski reduced basis via the algorithm of \cite rAFF85a&thinsp;, which
 * works by successive applications of the BB procedure for finding a
 * shortest vector. The bounds in the BB procedure are computed through a
 * Choleski decomposition performed in (double precision) floating-point
 * arithmetic. Numerical roundoff errors occur during these computations and
 * could (eventually) affect the results: Because of slightly wrong bounds in
 * the BB, one may miss a shorter vector and, as a result, (conceivably) not
 * obtain a true MRLB at the end of the reduction algorithm. In that case,
 * one may consider redoing the computations with the NTL type `RR`, used to
 * represent arbitrary-precision floating-point numbers (see module
 * \ref Types.h) but giving rise to much slower programs.
 *
 *   # Large numbers, matrices and polynomials
 *
 *    \anchor REF__sec1_sec_large
 *
 *   LatMRG can deal with very large moduli and multipliers. There is no
 * limit on size other than the size of the computer memory (and the CPU
 * time). For example, a generator with a modulus of a few hundred bits can
 * be analyzed easily. Operations on large integers are performed using the
 * GNU multi-precision package GMP \cite iGMP06a&thinsp;. GMP is a portable
 * library written in C for arbitrary precision arithmetic on integers,
 * rational numbers, and floating-point numbers. For vectors, matrices of
 * large numbers and polynomials, we use NTL \cite iSHO05a&thinsp;. NTL is a
 * high-performance, portable C++ library providing data structures and
 * algorithms for manipulating arbitrary length integers, and for vectors,
 * matrices, and polynomials over the integers and over finite fields. NTL
 * uses GMP as an underlying package for dealing with large numbers.
 *
 *   Of course, arithmetic operations with these structures are performed in
 * software and are significantly slower than the standard operations
 * supported by hardware. For this reason, most of the basic (low-level)
 * operations required by our higher-level classes have been implemented in
 * two or three versions. When building a basis or checking maximal period
 * conditions, the modulus and multipliers can be represented either as
 * <tt>long</tt>’s (32-bit integers) or <tt>ZZ</tt>’s (arbitrary large
 * integers). After a lattice basis and its dual have been constructed, when
 * working on the basis (finding a shortest vector, Minkowski reduction,
 * etc.), the vector elements can be represented either as <tt>double</tt>’s
 * (64-bit floating-point numbers) or <tt>RR</tt>’s (arbitrary large
 * floating-point numbers).
 *
 *   When performing a search for good generators, for instance, one can
 * first perform all the "screening" computations (involving many generators)
 * using standard type <tt>double</tt>, and then recompute (verify) with the
 * large floating-point numbers <tt>RR</tt> only for the retained generators.
 *
 */
